<!DOCTYPE html>
<html>
  <head>
  <title>
      
          Elasticsearch 分页 - Mitirrli
      
  </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="" />
  <link rel="shortcut icon" type="image/x-icon" href="/img/">

  
  
  
  
  
  <link rel="stylesheet" href="https://mitirrli.github.io/blog/style.min.6f642c5866835106e8a19b94463576436c99be9e41a8714ab3df3daa95f6bf90.css" integrity="sha256-b2QsWGaDUQbooZuURjV2Q2yZvp5BqHFKs989qpX2v5A=">
  
  
  
  <link rel="stylesheet" href="https://mitirrli.github.io/blog/style-dark.min.0a647fb6c07e04b77b54fa0515d0a683d39ecdb251dba960fe1f966f7ff36fc2.css" media="(prefers-color-scheme: dark)" integrity="sha256-CmR/tsB&#43;BLd7VPoFFdCmg9OezbJR26lg/h&#43;Wb3/zb8I=">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">

  
  

  <meta property="og:title" content="Elasticsearch 分页" />
<meta property="og:description" content="1. FROM &#43; SIZE 方案 1 2 3  from 指明了分页查询返回的结果的起始位置，而size参数则指明了分页查询的页容量 原理: 比如查询第二页的数据，每页有10条数据，就是查询前20条数据，然后截断前10条，只返回后面10条   1 2 3  存在的问题: 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mitirrli.github.io/blog/elasticsearch/page/" />
<meta property="article:published_time" content="2020-05-22T07:35:35+08:00" />
<meta property="article:modified_time" content="2020-10-27T17:18:02+08:00" />
<meta itemprop="name" content="Elasticsearch 分页">
<meta itemprop="description" content="1. FROM &#43; SIZE 方案 1 2 3  from 指明了分页查询返回的结果的起始位置，而size参数则指明了分页查询的页容量 原理: 比如查询第二页的数据，每页有10条数据，就是查询前20条数据，然后截断前10条，只返回后面10条   1 2 3  存在的问题: 1.">
<meta itemprop="datePublished" content="2020-05-22T07:35:35+08:00" />
<meta itemprop="dateModified" content="2020-10-27T17:18:02+08:00" />
<meta itemprop="wordCount" content="350">



<meta itemprop="keywords" content="php,elasticsearch," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:image" content="https://mitirrli.github.io/blog//img/"/>
<meta name="twitter:title" content="Elasticsearch 分页"/>
<meta name="twitter:description" content="1. FROM &#43; SIZE 方案 1 2 3  from 指明了分页查询返回的结果的起始位置，而size参数则指明了分页查询的页容量 原理: 比如查询第二页的数据，每页有10条数据，就是查询前20条数据，然后截断前10条，只返回后面10条   1 2 3  存在的问题: 1."/>

  <!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->

  <!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <![endif]-->

  </head>

  <body>
    
  <h1>Elasticsearch 分页</h1>
  <header>
  
  <div class="avatar">
    <img class="avatarMask" src="https://mitirrli.github.io/blog//img/" alt="">
    <a href="https://mitirrli.github.io/blog/"><img class="avatar-border" src="https://mitirrli.github.io/blog//img/avatar-border.svg" alt=""></a>
  </div>
  
  <h2><a class="author" href="https://mitirrli.github.io/blog/"></a></h2>
</header>

  
  
  
  <p class="date">May 22, 2020</p>
  
  
  
  <div id="tags">
    <ul>
      
        
        
          <li><a href="https://mitirrli.github.io/blog/tags/php/">php</a></li>
        
      
        
        
          <li><a href="https://mitirrli.github.io/blog/tags/elasticsearch/">elasticsearch</a></li>
        
      
    </ul>
  </div>
  
  
  <div id="contentBody">
    <h4 id="1-from--size-方案">1. FROM + SIZE 方案</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">from 指明了分页查询返回的结果的起始位置，而size参数则指明了分页查询的页容量

原理: 比如查询第二页的数据，每页有10条数据，就是查询前20条数据，然后截断前10条，只返回后面10条
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">存在的问题: 1. 分页的偏移值越大，执行分页查询时间越长

2. from + size 不能超过索引的 index.max_result_window 值
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">POST /_search
{
  &#34;from&#34;: 30,
  &#34;size&#34;: 10
}
GET /_search
{
  &#34;from&#34;: 30,
  &#34;size&#34;: 10
}

//两种方式均支持
</code></pre></td></tr></table>
</div>
</div><h4 id="2-scroll-深分页">2. SCROLL 深分页</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">该查询实现类似于消息消费的机制，首次查询的时候会在内存中保存一个历史快照以及游标(scroll_id)，记录当前消息查询的终止位置，下次查询的时候将基于游标进行消费
性能良好，维护成本高，在游标失效前，不会更新数据，不够灵活，一旦游标创建size就不可改变，适用于大量数据导出或者索引重建
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">$client = ClientBuilder::create()-&gt;build();
$params = [
    &#39;scroll&#39; =&gt; &#39;30s&#39;,          // how long between scroll requests. should be small!
    &#39;size&#39;   =&gt; 50,             // how many results *per shard* you want back
    &#39;index&#39;  =&gt; &#39;my_index&#39;,
    &#39;body&#39;   =&gt; [
        &#39;query&#39; =&gt; [
            &#39;match_all&#39; =&gt; new \stdClass()
        ]
    ]
];

// Execute the search
// The response will contain the first batch of documents
// and a scroll_id
$response = $client-&gt;search($params);

// Now we loop until the scroll &#34;cursors&#34; are exhausted
while (isset($response[&#39;hits&#39;][&#39;hits&#39;]) &amp;&amp; count($response[&#39;hits&#39;][&#39;hits&#39;]) &gt; 0) {

    // **
    // Do your work here, on the $response[&#39;hits&#39;][&#39;hits&#39;] array
    // **

    // When done, get the new scroll_id
    // You must always refresh your _scroll_id!  It can change sometimes
    $scroll_id = $response[&#39;_scroll_id&#39;];

    // Execute a Scroll request and repeat
    $response = $client-&gt;scroll([
        &#39;body&#39; =&gt; [
            &#39;scroll_id&#39; =&gt; $scroll_id,  //...using our previously obtained _scroll_id
            &#39;scroll&#39;    =&gt; &#39;30s&#39;        // and the same timeout window
        ]
    ]);
}
</code></pre></td></tr></table>
</div>
</div><h4 id="3-search-after">3. Search After</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">原理: 使用历史条件过滤掉数据，通过上一页的结果帮助检索下一页，通过将sort值与search_after参数一起使用，以开始返回在这个结果列表之后的任何文档

注意: 当使用search_after参数时，from的值必须被设为0或者-1
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ curl -XGET <span class="s2">&#34;http://localhost:9200/bank/_search&#34;</span> -H <span class="s1">&#39;Content-Type: application/json&#39;</span> -d<span class="s1">&#39;
</span><span class="s1">  {
</span><span class="s1">      &#34;size&#34;: 10,
</span><span class="s1">      &#34;query&#34;: {
</span><span class="s1">          &#34;match&#34; : {
</span><span class="s1">              &#34;address&#34; : &#34;place&#34;
</span><span class="s1">          }
</span><span class="s1">      },
</span><span class="s1">      &#34;sort&#34;: [
</span><span class="s1">          {&#34;balance&#34;: &#34;asc&#34;},
</span><span class="s1">          {&#34;_id&#34;: &#34;desc&#34;}
</span><span class="s1">      ]
</span><span class="s1">  }&#39;</span>

$ curl -XGET <span class="s2">&#34;http://localhost:9200/bank/_search&#34;</span> -H <span class="s1">&#39;Content-Type: application/json&#39;</span> -d<span class="s1">&#39;
</span><span class="s1">  {
</span><span class="s1">      &#34;size&#34;: 10,
</span><span class="s1">      &#34;query&#34;: {
</span><span class="s1">          &#34;match&#34; : {
</span><span class="s1">              &#34;address&#34; : &#34;place&#34;
</span><span class="s1">          }
</span><span class="s1">      },
</span><span class="s1">      &#34;search_after&#34;: [4652, &#34;590&#34;],
</span><span class="s1">      &#34;sort&#34;: [
</span><span class="s1">          {&#34;balance&#34;: &#34;asc&#34;},
</span><span class="s1">          {&#34;_id&#34;: &#34;desc&#34;}
</span><span class="s1">      ]
</span><span class="s1">  }&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://blog.csdn.net/yiyiholic/article/details/81661919">参考文章</a></p>
<p><a href="https://blog.csdn.net/zzh920625/article/details/84593590">参考文章</a></p>
<p><a href="https://github.com/elastic/elasticsearch-php">参考文档</a></p>

  </div>
  <footer>
  <p>
  &copy;  .
  Powered by <a href="https://gohugo.io/">Hugo</a>
  using the <a href="https://github.com/koirand/pulp/">pulp</a> theme.
  </p>
</footer>


  </body>
</html>
