[{"categories":["php"],"content":" nginx本身不能处理php,当收到请求后,如果是php请求,在本文中,他将请求发送给fastcgi管理进程处理,fastcgi管理进程会选择子进程处理完返回结果给nginx\n 为了防止破坏我们本机的环境,我们搭建一个ubuntu的docker环境 1. 安装nginx 1  $ apt-get update \u0026\u0026 apt install nginx   2. 编译安装php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ docker pull ubuntu:latest $ docker run --name ubuntu -d ubuntu /bin/bash -c \"while true; do echo 1; sleep 1; done\" $ docker exec -it ubuntu bash //进入容器 $ cd /tmp $ apt-get update \u0026\u0026 apt install wget vim gcc pkg-config systemctl make libxml2-dev libsqlite3-dev //下载之后需要的一些tool $ wget -c https://downloads.php.net/~carusogabriel/php-8.0.0beta3.tar.gz //我这边直接安装当前最新版 $ tar zxvf php-8.0.0beta3.tar.gz $ cd php-8.0.0beta3 $ ./configure --prefix=/tmp/php-8.0.0beta3/output --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data //在配置的时候设置路径(安装的路径前缀),选择开启fpm,同时设置fpm的user和group $ make //编译,这一步需要比较长的时间(之后sapi/cli目录里就已经有了php的可执行文件) $ make install //安装(make install后可以执行$prefix/bin/php)   3. 重命名配置文件 1 2 3 4  # 此时在/tmp/php-8.0.0beta3/output/sbin目录下已经有了php-fpm的可执行文件 $ mv /tmp/php-8.0.0beta3/output/etc/php-fpm.conf.default /tmp/php-8.0.0beta3/output/etc/php-fpm.conf $ mv /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf.default /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf   4. 使用unix套接字通讯 1 2 3 4 5 6  $ vim /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf // 修改 listen = /var/run/php-fpm/php8-fpm.sock $ mkdir -p /var/run/php-fpm \u0026\u0026 touch /var/run/php-fpm/php8-fpm.sock \u0026\u0026 chown -R www-data:www-data /var/run/php-fpm/php8-fpm.sock //创建socket文件 $ /tmp/php-8.0.0beta3/output/sbin/php-fpm -D //启动php-fpm   5. 创建一个php文件 1 2 3  $ chown -R www-data:www-data /opt //给予opt文件夹权限 $ vim /opt/index.php   1 2 3  \u003c?php echo phpinfo();   1  $ chown www-data:www-data /tmp/index.php   5. nginx创建一个配置文件 1  $ vim /etc/nginx/conf.d/demo.conf //创建一个配置文件   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  server { listen 80; server_name 127.0.0.1; root /opt; location / { index index.html index.htm index.php; if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?s=$1 last; rewrite index.php/(.*)$ /index.php?s=$1 last; break; } } location ~ \\.php$ { fastcgi_pass unix:/var/run/php-fpm/php8-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } }   1 2 3  $ nginx -c /etc/nginx/nginx.conf $ nginx -s reload   1  $ curl 127.0.0.1 //可以看到成功结果   ","description":"","tags":["php-fpm","php"],"title":"Php Fpm 和 Nginx","uri":"/blog/php/php-fpm/"},{"categories":["git"],"content":"Gitlab版本升级 公司目前gitlab版本是9.5.5,因升级服务器顺道把gitlab也升到最新,这里记录下历程。\n备份Gitlab 1  $ gitlab-rake gitlab:backup:create   执行命令进行备份，将会生成一个命名格式为_gitlab_backup.tar的压缩包\nGitlab升级 升级历程: 9.5.5 -\u003e 9.5.9 -\u003e 9.5.10 -\u003e 10.8.7 -\u003e 11.11.8 -\u003e 12.0.12 -\u003e 12.10.14 -\u003e 13.0.12 -\u003e 13.2.3 按照官网升级顺序依次升级\n下载deb包(*为版本号) 1  $ wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/xenial/main/g/gitlab-ce/gitlab-ce_*-ce.0_amd64.deb   安装deb包 1  $ dpkg -i *.deb   查看版本 1  $ cat /opt/gitlab/embedded/service/gitlab-rails/VERSION   Gitlab恢复 首先关闭服务\n1  $ gitlab-rake gitlab:backup:restore BACKUP 1597233443_2020_08_12_9.3.1   Gitlab 502解决(查看pid) 1  $ gitlab-ctl status   ","description":"","tags":["gitlab"],"title":"Update Gitlab","uri":"/blog/gitlab/update/"},{"categories":["docker"],"content":"快速使用 1 2 3 4 5  $ git clone https://github.com/Mitirrli/docker-compose.git $ cp .env.example .env 之后在项目根目录放置自己代码, 在.docker/nginx/conf.d下放置nginx配置文件即可   环境变量 # Port PHP5_PORT=9005 PHP7_PORT=9007 WEB_PORT=80 REDIS_PORT=6379 # Container PHP5_CONTAINER_NAME=php5 PHP7_CONTAINER_NAME=php7 NGINX_CONTAINER_NAME=web REDIS_CONTAINER_NAME=redis # Version PHP5_VERSION=5.5.38-fpm-alpine PHP7_VERSION=7.1.30-fpm-alpine PHP7REDIS_VERSION=5.3.1 PHP5REDIS_VERSION=5.3.1 REDIS_VERSION=6.0.6-alpine3.12 NGINX_VERSION=latest XLSWRITER_VERSION=1.3.6 SWOOLE_VERSION=4.5.2 # Ini INSTALL_XDEBUG=true INSTALL_REDIS=true INSTALL_XLSWRITER=false INSTALL_SWOOLE=false docker-compose命令 1 2 3 4 5 6 7 8 9 10 11  $ docker-compose up //前台启动 $ docker-compose up -d //后台启动 $ docker-compose stop //暂停容器 $ docker-compose start //启动容器 $ docker-compose down -v //停止并删除容器 $ docker exec -it [container_name] sh //进入容器   开启Xdebug 1 2 3 4 5  1 . 配置 INSTALL_XDEBUG 为true 2 . Preferences -\u003e Set Debug port 9001 3 . Select path mapping   ","description":"","tags":["docker","php"],"title":"Docker 搭建php环境","uri":"/blog/docker/php-environment/"},{"categories":["kubernetes"],"content":"K8S遇到的问题记录 K8S节点状态无法调度,状态为SchedulingDisabled 解决方案(*为ip):\n1  $ kubectl patch no * -p '{\"spec\": {\"unschedulable\": false}}'   Back-off restarting failed container 根据Describe Pod,pod内的Container已完成.但是Pod的生命周期非常短,要使Pod持续运行,您必须指定一个永远不会完成的任务.\nK8S挂载单个文件 使用subPath,部分代码如下:\n1 2 3 4  volumeMounts:- mountPath:/var/www/html/.envname:envsubPath:.env  K8S获取崩溃容器的应用日志 1 2 3 4  如果你的容器重启,kubectl logs命令将显示当前容器的日志。 如果你想看前一个容器的日志,添加--previous kubectl logs mypod --previous   ","description":"","tags":["kubernetes"],"title":"Schedule Disabled","uri":"/blog/kubernetes/question-record/"},{"categories":["git"],"content":" 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立\n 添加子模块 1 2 3  # 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对URL来添加新的子模块 $ git submodule add ... //默认情况下,子模块会将子项目放到一个与仓库同名的目录中,如果你想要放到其他地方,那么可以在命令结尾添加一个不同的路径   1 2 3  此时.gitmodules文件保存了项目 URL 与已经拉取的本地目录之间的映射。 修改子模块url: git config submodule.\u003c模块名\u003e.url \u003c私有URL\u003e 来覆盖这个选项的值   克隆含有子模块的项目 1 2 3 4 5  $ git clone \u003curl\u003e $ git submodule init //初始化本地配置文件 $ git submodule update //从该项目中抓取所有数据并检出父项目中列出的合适的提交   1 2 3 4  $ git clone --recurse-submodules \u003curl\u003e //传递--recurse-submodules选项,它就会自动初始化并更新仓库中的每一个子模块,包括可能存在的嵌套子模块 # 如果你已经克隆了项目但忘记了--recurse-submodule,那么可以运行git submodule update --init将git submodule init和git submodule update合并成一步 # 如果还要初始化、抓取并检出任何嵌套的子模块,请使用简明的git submodule update --init --recursive   在主项目更新子模块 1 2 3 4 5  $ git submodule update --remote \u003c模块名\u003e $ git config -f .gitmodules submodule.\u003c模块名\u003e.branch \u003c分支名\u003e //设置模块默认的分支 # 如果不用 -f .gitmodules 选项,那么它只会为你做修改   更新包含子模块的项目 1 2 3 4  $ git submodule update --init --recursive //如果MainProject提交了你刚拉取的新子模块,应该在 git submodule update 后面添加--init选项,如果子模块有嵌套的子模块,则应使用--recursive选项 # 如果你想自动化此过程,那么可以为 git pull 命令添加--recurse-submodules选项 # 如果你想让Git总是以--recurse-submodules拉取,可以将配置选项submodule.recurse设置为true.此选项会让Git为所有支持--recurse-submodules的命令使用该选项(除clone以外)   子模块遍历 1 2 3  # 有一个foreach子模块命令,它能在每一个子模块中运行任意命令 $ git submodule foreach 'git stash'   增加子模块别名 1 2 3  $ git config alias.sdiff '!'\"git diff \u0026\u0026 git submodule foreach 'git diff'\" $ git config alias.spush 'push --recurse-submodules=on-demand' $ git config alias.supdate 'submodule update --remote --merge'   删除子模块 1 2 3  $ git submodule deinit \u003c子模块\u003e //逆初始化模块 $ git rm --cached \u003c子模块\u003e //删除.gitmodules中记录的模块信息(--cached选项清除.git/modules中的缓存) $ git commit -m 'comment'   git官方文档\n","description":"","tags":["git"],"title":"Git 子模块","uri":"/blog/git/submodule/"},{"categories":["php"],"content":"1. 设置时区  date_default_timezone_set — 设定用于一个脚本中所有日期时间函数的默认时区\n date_default_timezone_set ( string $timezone_identifier ) : bool 用法 1  date_default_timezone_set('Asia/Shanghai');    ini_set — 为一个配置选项设置值，这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。\n 用法 1  ini_set('date.timezone','Asia/Shanghai');   支持使用ini_set修改的参数附录\n2. 生成一个格式化的时间  date — 格式化一个本地时间／日期\n date ( string $format [, int $timestamp ] ) : string    format 字符 描述 返回值示例     天 — —   d 一个月中的第几天，有前导0的2位数字 从01到31   D 3个字符表示的星期几 3个字符表示的星期几，从Mon到Sun   j 一个月中的第几天，无前导0 从1到31   N ISO-8601 规定的数字表示的星期几 从1(表示星期一)到7(表示星期日)   w 数字表示的星期几 从0(星期日)到6(星期六)   z 一年中的第几天，从0开始计数 从 0 到 365   周 — —   W ISO-8601规范的一年中的第几周，周一视为一周开始。 42(本年第42周)   月 — —   m 带有0前导的数字表示的月份 从01到12   n 月份的数字表示，无前导0 从1到12   t 给定月份中包含多少天 从28到31   年 — —   Y 4位数字的年份 1999或2003   y 2位数字的年份 99或03   时间 — —   a 上午还是下午，2位小写字符 am或pm   A 上午还是下午，2位大写字符 AM或PM   g 小时，12时制，无前导0 从1到12   G 小时，24时制，无前导0 从0到23   h 小时，12时制，有前导0的2位数字 从01到12   H 小时，24时制，有前导0的2位数字 从00到23   i 分钟，有前导0的2位数字 从00到59   s 秒，有前导0的2位数字 从00到59   完整的日期/时间 — —   c ISO 8601日期及时间 2004-02-12T15:19:21+00:00   U 时间戳，以秒为单位 1539100800    更多可以参考php手册\n3. 将时间转换为时间戳  strtotime — 将任何字符串的日期时间描述解析为 Unix 时间戳\n 用法 1 2 3 4  strtotime('+1 day'); strtotime(\"+1 week 2 days 4 hours 2 seconds\"); strtotime(\"next Thursday\"); strtotime(\"last Monday\");   常用用法 1 2 3 4  strtotime(date('Y-m-d')); strtotime('+1 day', strtotime(date('Y-m-d'))); strtotime(\"first day of next month\", strtotime(\"2017-01-31\")); strtotime(\"last day of last month\", strtotime(\"2017-03-31\"));   注意 1 2 3 4 5 6 7 8  var_dump(date(\"Y-m-d\", strtotime(\"-1 month\", strtotime(\"2017-03-31\")))); //输出2017-03-03 var_dump(date(\"Y-m-d\", strtotime(\"+1 month\", strtotime(\"2017-08-31\")))); //输出2017-10-01 var_dump(date(\"Y-m-d\", strtotime(\"next month\", strtotime(\"2017-01-31\")))); //输出2017-03-03 var_dump(date(\"Y-m-d\", strtotime(\"last month\", strtotime(\"2017-03-31\")))); //输出2017-03-03   解决方案 1 2 3 4 5 6 7 8  var_dump(date(\"Y-m-d\", strtotime(\"last day of -1 month\", strtotime(\"2017-03-31\")))); //输出2017-02-28 var_dump(date(\"Y-m-d\", strtotime(\"first day of +1 month\", strtotime(\"2017-08-31\")))); //输出2017-09-01 var_dump(date(\"Y-m-d\", strtotime(\"first day of next month\", strtotime(\"2017-01-31\")))); //输出2017-02-01 var_dump(date(\"Y-m-d\", strtotime(\"last day of last month\", strtotime(\"2017-03-31\")))); //输出2017-02-28   更多可以参考令人困惑的strtotime\n","description":"","tags":["php"],"title":"Php 部分时间函数","uri":"/blog/php/time/"},{"categories":["linux"],"content":" 为了高效的使用Linux系统，使用Linux命令是必不可少的，有很多常用的Linux命令更是要必须掌握的\n 1. uptime  uptime(选项)\n 1 2 3 4 5 6 7  # uptime命令可以显示的信息显示依次为:现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载 $ uptime 7:41 up 17:20, //系统当前时间,主机已运行时间,时间越大,说明你的机器越稳定 2 users, //用户总连接数 load averages: 3.86 3.73 3.33 //统计最近1,5,15分钟的系统平均负载(统计最近1,5,15分钟的系统平均负载)   2. tail  tail(选项)(指定要显示尾部内容的文件列表)\n 1 2 3 4 5 6 7  $ tail -n 3 \u003cfile\u003e //-n 指定显示末尾的n行,默认为10行 $ tail +20 \u003cfile\u003e //显示文件file的内容,从第20行至文件末尾 $ tail -c 10 \u003cfile\u003e //-c 指定显示的字符 $ tail -f \u003cfile\u003e //显示文件最新追加的内容   3. find  find(选项)(查找文件的起始目录)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ find . -name *.md //查找当前目录下以md结尾的文件 $ find . -name 'linux' //查找当前目录下所有包含'linux'关键字的文件 $ find / ! -name \"*.txt\" //找出/下不是以.txt结尾的文件 $ find . -type 类型参数(f 普通文件,l 符号连接,d 目录,c 字符设备,b 块设备,s 套接字,p Fifo) $ find . -type f -name \"*.txt\" -delete //删除当前目录下所有.txt文件 $ find . -type f -perm 777 //当前目录下搜索出权限为777的文件 $ find . -type f -user \u003cuser\u003e //找出当前目录用户拥有的所有文件 $ find . -type f -group \u003cgroup\u003e //找出当前目录用户组拥有的所有文件   4. wc  wc(选项)(文件列表)\n 1 2 3 4 5 6 7 8 9 10 11  # 利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称,或是所给予的文件名为“-”,则wc指令会从标准输入设备读取数据 $ wc -c \u003cfiles\u003e //显示Bytes数 $ wc -l \u003cfiles\u003e //显示列数 $ wc -w \u003cfiles\u003e //显示字数 # wc -l 可以配合｜进行统计（例如可以统计文件的行数，进程的个数） # ps -ef | grep php | wc -l # cat test.txt | grep 90 | wc -l   5. grep  grep是一种强大的文本搜索工具,它能使用正则表达式搜索文本,并把匹配的行打印出来,文件夹的话需要递归搜索-R\n 1 2 3 4 5 6 7  $ grep \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //文件中查找 $ grep -c \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //统计文件或者文本中包含匹配字符串的行数 $ grep -E \"[1-9]+\" //使用正则表达式 -E 匹配 $ grep -n \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //在显示符合范本样式的那一列之前,标示出该列的编号   6. lsof  lsof命令用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行\n 1 2 3 4 5 6 7  $ lsof -i:\u003cport\u003e //列出谁在使用某个端口 $ lsof -i udp:\u003cport\u003e //列出谁在使用某个特定的udp端口 $ lsof -i tcp:\u003cport\u003e //列出谁在使用某个特定的tcp端口 $ lsof -u \u003cusername\u003e //列出某个用户打开的文件信息   7. ps  ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的\n 1 2 3 4 5  $ ps -A //显示所有进程信息 $ ps -u root //显示指定用户信息 $ ps -ef //显示所有进程信息,连同命令行   8. df  df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息\n 1 2 3  $ df -h //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高 $ df -a //查看全部文件系统   9. du  du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的\n 1 2 3 4 5 6 7 8 9  $ du -h \u003cfile\u003e //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高 $ du -c \u003cfile\u003e //使用-c[--total]除了显示个别目录或文件的大小外,同时也显示所有目录或文件的总和 $ du --max-depth=\u003cnum\u003e \u003cfile\u003e //设置最大深度 $ du -sh \u003cfile\u003e //仅显示总计,只列出最后加总的值 $ du --exclude=\u003cdir\u003e //--exclude=\u003c目录或文件\u003e 略过指定的目录或文件   10. ln  ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用\"-s\"选项\n 1 2 3 4 5 6 7 8 9 10  # Linux链接分两种,一种被称为硬链接(Hard Link),另一种被称为符号链接(Symbolic Link).默认情况下,ln命令产生硬链接 $ ln -s //对源文件建立符号连接,而非硬连接 # 对硬链接有如下限制: # 1. 不能对目录文件做硬链接 # 2. 不能在不同的文件系统之间做硬链接,链接文件和被链接文件必须位于同一个文件系统中 # 符号链接没有硬链接的限制,可以对目录文件做符号链接,也可以在不同文件系统之间做符号链接 # 用ln -s命令建立符号链接时,源文件最好用绝对路径名,这样可以在任何工作目录下进行符号链接.而当源文件用相对路径时,如果当前的工作路径与要创建的符号链接文件所在路径不同,就不能进行链接   如需深入理解,可以参考这篇文章’软链接’和’硬链接’的区别\n11. ls  ls命令用来显示目标列表\n 1 2 3 4 5  $ ls -a //显示所有档案及目录(显示隐藏文件) $ ls -i //显示文件索引节点号(inode).一个索引节点代表一个文件[具有相同的索引节点(inode)号的两个文本本质上是同一个文件(除文件名不同外)] $ ls -l //以长格式显示目录下的内容列表.输出的信息从左到右依次包括文件名,文件类型,权限模式,硬连接数,所有者,组,文件大小和文件的最后修改时间等 $ ls -t //最近修改的文件显示在最上面 $ ls -h //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高   12. mkdir  mkdir命令用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名\n 1 2  $ mkdir -m 755 /usr/test //建立目录的同时设置目录的权限 $ mkdir -p /usr/test //若所要建立目录的上层目录目前尚未建立,则会一并建立上层目录   ","description":"","tags":["linux"],"title":"Linux 常用命令","uri":"/blog/linux/script/"},{"categories":["php"],"content":"有用的php命令行命令 1. 查看当前已安装的扩展 1  $ php -m   2. 查看当前php版本 1  $ php -v   3. 查看扩展版本 1  $ php --ri 扩展名   4. 快速查看扩展版本 1  $ php -i | less   5. 查看php配置文件路径 1  $ php -i | grep php.ini   6. 执行文件(检查代码语法是否正确) 1  $ php -f 文件名   7. 直接执行代码 1  $ php -r 'echo 1;'   8. 检查代码语法 1  $ php -l 文件名   9. 查看帮助 1  $ php -h   10. 查看当前php可执行文件位置 1  $ which php   11. 开启服务 1  $ php -S 0.0.0.0:1234   12. 读取特定的ini文件 1  $ php -c /usr/local/etc/php/php.ini   ","description":"","tags":["php"],"title":"Php Command Script","uri":"/blog/php/script/"}]
