[{"categories":["c"],"content":"1. 下载最新版的 php $ axel -n 6 https://github.com/php/php-src/archive/php-8.0.0RC3.tar.gz //axel是一个多线程下载工具,大大提升了下载速度 2. 编译 php $ ./buildconf \u0026\u0026 ./configure --prefix=[PATH] --with-iconv=$(brew --prefix libiconv) $ make $ make install 3. 构建 c 扩展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ cd ext //官方拓展目录 $ ./ext_skel.php --ext testextension //创建扩展 $ cd testextension $ sudo ../../output/bin/phpize $ ./configure --with-php-config=[PATH]/bin/php-config $ make \u0026\u0026 make install $ echo 'extension=testextension.so' \u003e\u003e ../../output/lib/php.ini //写入配置文件中 $ ../../output/bin/php -m //此时已经可以看到扩展已经存在   4. 使用对应的方法 $ ../../output/bin/php -r \"echo test1();\" $ ../../output/bin/php -r \"echo test2();\" ","description":"","tags":["php","c"],"title":"编译 PHP \u0026\u0026 构建 c 扩展","uri":"/blog/php/compile/"},{"categories":["c"],"content":"C 示例: 1  $ vim hello.world.c   1 2 3 4 5 6 7 8  #include \u003cstdio.h\u003e int main() { printf(\"Hello World\"); return 0; }   1 2  # 编译项目 gcc hello.world.c -o hello-example1   C++ 示例: 1  $ vim hello.world.cpp   1 2 3 4 5 6 7 8 9 10  #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello World\"; return 0; }   1  g++ hello.world.cpp -o hello-example2   ","description":"","tags":["c","c++"],"title":"C 和 C++ 入门示例","uri":"/blog/c++/basic-usage/"},{"categories":["chrome"],"content":" vimium 是 vim 和 chrome 结合，让你不用移动鼠标就能跳转页面，切换标签，打开历史记录，打开书签等等。\n 使用方法: 1. F (Open link in new tab) 2. f (Open link in current tab) 3. J (后退) 4. K (前进) 5. / (搜索) 6. o (快速搜索) 7. r (刷新) ","description":"","tags":["vim","chrome"],"title":"给 Chrome 安上 Vimium","uri":"/blog/chrome/vimium/"},{"categories":["php"],"content":" Garbage Collector 简称 GC\n 关于引用计数 1 2 3 4 5 6 7 8  \u003c?php $a = \"new string\"; $b = $a; xdebug_debug_zval('a'); // a: (interned, is_ref=0)='new string'   ","description":"","tags":["php"],"title":"Php 垃圾回收机制","uri":"/blog/php/gc/"},{"categories":["php"],"content":"Part 1. PHP FPM 和 NGINX  nginx 本身不能处理 php,当收到请求后,如果是 php 请求,在本文中,他将请求发送给 fastcgi 管理进程处理,fastcgi 管理进程会选择子进程处理完返回结果给 nginx\n 为了不破坏本机的环境,搭建一个 ubuntu 的 docker 环境 1. CGI 和 FastCGI 1 2 3 4 5  1. CGI(common gateway interface 公共网关接口) 对于动态的请求，需要用到cgi协议，将请求数据转换成php能理解的信息，然后php根据这些信息返回的信息也要通过cgi协议转换成nginx可以理解的信息，最后nginx接到这些信息再返回给浏览器 2. FastCGI 传统的cgi协议在每次连接请求时，会开启一个进程进行处理，处理完毕会关闭该进程，周而复始。因此有多少个连接就有多少个cgi进程，过多的进程会消耗资源和内存   php-cgi  php-cgi 是 php 提供给 web serve 的 cgi 协议接口程序\n 1 2 3 4 5  当每次接到http前端服务器的请求都会开启一个php-cgi进程进行处理 而且开启的php-cgi的过程中会先要重载配置，数据结构以及初始化运行环境，如果更新了php配置，那么就需要重启php-cgi才能生效 直接杀死php-cgi进程,php就不能运行了(PHP-FPM没有这个问题,守护进程会平滑从新生成新的子进程）   php-fpm  php-fpm 是 php 提供给 web serve 的 fastcgi 协议接口程序\n 1 2 3 4 5 6 7 8 9  PHP-FPM 允许一个进程对多个连接进行处理，而不会立即关闭这个进程，而是会接着处理下一个连接,它可以说是php-cgi的一个管理程序，是对php-cgi的改进 php-fpm会开启多个php-cgi程序，并且php-fpm常驻内存 每次web serve服务器发送连接过来的时候，php-fpm将连接信息分配给下面其中的一个子程序php-cgi进行处理，处理完毕这个php-cgi并不会关闭，而是继续等待下一个连接，这也是fast-cgi加速的原理 但是由于php-fpm是多进程的，而一个php-cgi基本消耗7-25M内存，因此如果连接过多就会导致内存消耗过大 php-fpm将新的连接发送给新的子程序php-cgi，这个时候加载的是新的配置，而原先正在运行的php-cgi还是使用的原先的配置，等到这个连接后下一次连接的时候会使用新的配置初始化，这就是平滑过渡   FastCGI 的工作流程 1 2 3 4  Web Server启动时载入FastCGI进程管理器 FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了   参考文章\n2. 编译安装 php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ docker pull ubuntu:latest $ docker run --name ubuntu --cap-add=SYS_PTRACE -p 6767:80 -d ubuntu /bin/bash -c \"while true; do echo 1; sleep 1; done\" $ docker exec -it ubuntu bash //进入容器 $ cd /tmp $ sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list //使用国内镜像 $ apt-get update \u0026\u0026 apt install -y wget curl vim gcc pkg-config systemctl make libxml2-dev libsqlite3-dev //下载之后需要的一些tool $ wget -c https://downloads.php.net/~carusogabriel/php-8.0.0beta3.tar.gz //我这边直接安装当前最新版 $ tar zxvf php-8.0.0beta3.tar.gz $ cd php-8.0.0beta3 $ ./configure --prefix=/tmp/php-8.0.0beta3/output --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data //在配置的时候设置路径(安装的路径前缀),选择开启fpm,同时设置fpm的user和group $ make //编译,这一步需要比较长的时间(之后sapi/cli目录里就已经有了php的可执行文件) $ make install //安装(make install后可以执行$prefix/bin/php,此时在/tmp/php-8.0.0beta3/output/sbin目录下已经有了php-fpm的可执行文件)   3. 重命名配置文件 1  $ mv /tmp/php-8.0.0beta3/output/etc/php-fpm.conf.default /tmp/php-8.0.0beta3/output/etc/php-fpm.conf \u0026\u0026 mv /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf.default /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf   4. 安装 nginx 1  $ apt install -y nginx   5. 使用 unix 套接字通讯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ mkdir -p /var/run/php-fpm $ vim /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf // 修改 listen = /var/run/php-fpm/php8-fpm.sock // 打开注释 listen.owner = www-data // 打开注释 listen.group = www-data // 打开注释 listen.mode = 0660 $ vim /tmp/php-8.0.0beta3/output/etc/php-fpm.conf // 打开注释 pid = run/php-fpm.pid // 打开注释 error_log = log/php-fpm.log $ /tmp/php-8.0.0beta3/output/sbin/php-fpm -R //启动php-fpm $ ps -ef | grep php-fpm //这样已经可以看到对应的php-fpm进程了   6. 创建一个 php 文件 1  $ vim /opt/index.php   1 2 3  \u003c?php echo phpinfo();   7. nginx 创建一个配置文件 1  $ vim /etc/nginx/conf.d/demo.conf //创建一个配置文件   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  server { listen 80; server_name 127.0.0.1; root /opt; location / { index index.html index.htm index.php; if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?s=$1 last; rewrite index.php/(.*)$ /index.php?s=$1 last; break; } } location ~ \\.php$ { fastcgi_pass unix:/var/run/php-fpm/php8-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } }   1 2 3 4 5  $ systemctl stop nginx $ nginx -c /etc/nginx/nginx.conf $ nginx -s reload //reload会重新加载配置文件   1  $ curl 127.0.0.1 //在容器中执行本命令可以看到成功结果,容器外访问http://127.0.0.1:6767/可以查看对应详情   Part 2. PHP FPM配置 1. slow log 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ cd /tmp/php-8.0.0beta3/output \u0026\u0026 mkdir log \u0026\u0026 chown -R www-data:www-data log # 慢日志目录在 /tmp/php-8.0.0beta3/output/log $ vim /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf //打开慢日志开关 ; The log file for slow requests ; Default Value: not set ; Note: slowlog is mandatory if request_slowlog_timeout is set slowlog = log/$pool.log.slow ; The timeout for serving a single request after which a PHP backtrace will be ; dumped to the 'slowlog' file. A value of '0s' means 'off'. ; Available units: s(econds)(default), m(inutes), h(ours), or d(ays) ; Default Value: 0 request_slowlog_timeout = 1s   PHP-FPM可以创建慢日志文件，但是却不能给慢日志文件写入内容\n2. 配置php-fpm 1  $ ps -ef | grep php-fpm //可以看到目前有1个Fastcgi进程管理器和2个Fastcgi子进程   1  $ vim /tmp/php-8.0.0beta3/output/etc/php-fpm.d/www.conf //修改配置文件   1 2 3 4 5 6 7 8 9  ; The number of child processes created on startup. ; Note: Used only when pm is set to 'dynamic' ; Default Value: (min_spare_servers + max_spare_servers) / 2 pm.start_servers = 4 ; The desired maximum number of idle server processes. ; Note: Used only when pm is set to 'dynamic' ; Note: Mandatory when pm is set to 'dynamic' pm.max_spare_servers = 4   1 2 3  $ kill -USR2 `cat /tmp/php-8.0.0beta3/output/var/run/php-fpm.pid` //重启php-fpm $ ps -ef | grep php-fpm //可以看到目前有1个Fastcgi进程管理器和4个Fastcgi子进程   3. php-fpm参数说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #php-fpm的运行权限。 #以什么用户什么组的权限来运行池fpm。 user = www group = www #php-fpm的运行方式，可以使端口，也可以使socke文件。 #如果是端口则是走tcp，如果是socket则直接读socket文件，这样性能相对更好。 listen = 127.0.0.1:9000 #拥有socket权限的用户，需要和上面的user、group配置相结合。 #如果采用的端口的方式，则不配置。 listen.owner = www listen.group = www listen.mode = 0660 #这是php-fpm端口连接的地址。多个用\",\"隔开。默认任意地址都可以连接。 #例如Nginx和php-fpm不在同一台服务器上，这里的值就是Nginx服务的ip地址。 #当Nginx和php-fpm配置在同一台服务器上，则直接写127.0.0.1即可。 listen.allowed_clients = 127.0.0.1 #pid进程文件存放的位置，当我们启用一个php服务， #则会自动创建一个该pid文件，其实我们可以直接把该文件理解理解php-fpm的进程号文件， #两则是等价的。默认为none。 pid = /opt/remi/php72/root/var/run/php-fpm/php-fpm.pid #错误日志位置，默认：安装路径 #INSTALL_PREFIX#/log/php-fpm.log。 #如果设置为syslog，log就会发送给syslogd服务而不会写进文件里。 error_log = /opt/remi/php72/root/var/log/php-fpm/error.log #PHP限制的文件扩展名 security.limit_extensions = .php .php3 .php4 .php5 .php7 #系统日志标示，如果跑了多个fpm进程，需要用这个来区分日志是谁的。 syslog.ident = php-fpm #日记登记，可选：alert, error, warning, notice, debug。 log_level = notice #紧急重启阈值，需要与下面emergency_restart_interval参数一起配置。 emergency_restart_threshold = 60 # 紧急重启阈值的时间范围。在此参数设置的时间内， # 出现SIGSEGV或SIGBUS的子进程数超过emergency_restart_threshold参数设置的值。 # 那么fpm就会优雅的重启，值是0表示off这个功能，可用的单位有：s秒,m分,h时,d天。 emergency_restart_interval = 60s #设置子进程接受主进程复用信号的超时时间。 process_control_timeout = 0 #当动态管理子进程时，fpm最多能fork多少个进程，0表示无限制， # 这是所有进程池能启动子进程的总和，谨慎使用。 process.max = 128 #设置子进程的优先级，在master进程以root用户启动时有效； #如果没有设置，子进程会继承master进程的优先级，值范围-19(最高)到20(最低)，默认不设置。 process.priority = -19 #设置成no用于调试bug，默认为yes。 daemonize = yes #master进程最多能打开的文件数量。默认采用系统设置的值。 rlimit_files = 1024 #master进程核心rlimit限制值；可选unlimited或\u003e=0的整数，默认为系统的值。 rlimit_core = 0 #事件处理机制，默认自动检测，可选值：select，poll， #epoll(linux\u003e=2.5.44)，kqueue，/dev/poll，port events.mechanism = epoll #fpm想系统发送状态的频率。单位有s,m,h。 #前提是fpm被设置会系统服务。 systemd_interval = 10s   4. php-fpm进程进程池配置  1个子进程基本上占用内存在30MB-40MB左右,需要根据自己的主机配置以及业务情况给出合适的方案\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  #php-fpm的队列长度。 listen.backlog = 65535 #php进程池权限，同样要master进程是root用户才有效， #和上面的全局设置一样，不设置的话会继承master进程的优先级。 process.priority = -19 #子进程管理方式 #static(静态配置，在启动php-fpm时根据该值创建固定的子进程数量)； #dynamic(动态配置，在启动php-fpm时根据pm.start_servers的值初始化对应的子进程数，至少一个子进程)； #ondemand(按需配置，在启动php-fpm时不创建子进程，而是根据请求动态fork子进程)； pm = dynamic #最大子进程数量 pm.max_children = 5 #初始化子进程数量，与上面的pm = dynamic配置使用。 pm.start_servers = 2 #服务器闲置时最少保持2个子进程，不够这个数就会创建，只适用动态dynamic管理方式 pm.min_spare_servers = 2 #服务器闲置时最多要有几个，多了会kill，只适用动态dynamic管理方式 pm.max_spare_servers = 3 #子进程闲置时间，也就是说子进程没有可处理的任务时，在该之间使就会被killed。 pm.process_idle_timeout = 10s #每个子进程最大的处理请求数量。在一定程度上可以防止内存泄漏。 pm.max_requests = 500 #php-fpm状态监控的uri pm.status_path string #php-fpm监控页面的 ping 网址。 #如果没有设置，则无法访问 ping 页面。 #该页面用于外部检测php-fpm是否存活并且可以响应请求。请注意必须以斜线开头（/）。 ping.path string #用于定义ping请求的返回响应。返回为 HTTP 200 的 text/plain 格式文本。默认值：pong。 ping.response string #设置worker的nice(2)优先级（如果设置了的话）。 #该值从 -19（最高优先级） 到 20（更低优先级）。 #默认值：不设置 process.priority int #检测路径时使用的前缀 prefix string #访问文件日志，没啥用处，比如yii2每次都记录访问index.php，只是记录真实的PHP文件。 access.log = var/log/$pool.access.log #php的慢日志 slowlog = var/log/$pool.log.slow #慢日志时间阈值 request_slowlog_timeout = 2s #单个请求的超时时间，当php.ini设置的最大执行时间未生效，则交由它来处理。 request_terminate_timeout = 3s #最大打开句柄数，默认为系统值。 rlimit_files = 1024 #最多的核心使用数，默认为系统分配。 rlimit_core = 0   ","description":"","tags":["php-fpm","php","nginx","docker"],"title":"PHP FPM","uri":"/blog/php/php-fpm/"},{"categories":["vscode"],"content":" 记录一下自己的配置，每个人可以有自己的配置，仅供参考\n 1. 一次搜索所有文件的文本 Cmd(⌘) + Shift(⇧) + F 2. 打开终端 Ctrl(⌃) + Shift(⇧) + ` 3. 修改快速打开文件快捷键(在当前的项目工程里，全局搜索文件名)  用惯了 storm 的 Cmd+E 快速跳转，故继续保留\n 先按 Cmd(⌘) + k, 再按 Cmd(⌘) + S, 将 Cmd(⌘) + P 改为 Cmd(⌘) + E 输入 \u003e 可以回到主命令框 Ctrl + Shift + P 模式 4. 修改跳转方法为 Cmd(⌘) + B 5. 将隐藏侧边栏修改为 Cmd(⌘) + ESC 6. 行缩进 Cmd(⌘) + [ Cmd(⌘) + ] 7. 将代码向上或向下移动 Option + ⬆ Option + ⬇ 8. 左右显示多个编辑器窗口 Cmd(⌘) + \\ 9. 切换窗口 Cmd(⌘) + num 10. 返回到上一个文件 Control + - 11. 代码折叠 Cmd(⌘) + Option + [ Cmd(⌘) + Option + ] 12. 进入禅模式 Cmd(⌘) + K 再按 Z 13. 依次选中当前选中的单词 Cmd(⌘) + D ","description":"","tags":["vscode"],"title":"Vscode 快捷键","uri":"/blog/vscode/short-key/"},{"categories":["vscode"],"content":"1. 汉化 vscode 看英文不是看不懂，但有中文必须优先中文 插件名: Chinese (Simplified) Language Pack for Visual Studio Code 2. vscode-icons 给不同的文件类型添加图标 3. PHP Intelephense PHP代码提示工具，代码提示、查找定义、类搜索等功能 编辑对应的配置，具体根据自己实际情况配置 \"intelephense.phpdoc.classTemplate\": { \"php.validate.executablePath\": \"/usr/local/bin/php\", \"php.executablePath\": \"/usr/local/bin/php\", \"window.zoomLevel\": 0, \"summary\": \"$1\", \"tags\": [ \"@package ${1:$SYMBOL_NAMESPACE}\" ] } 4. PHP Cs 1  $ composer require --dev squizlabs/php_codesniffer   5. PHP DocBlocker \"php-docblocker.extra\": [ \"\", \"@Author huanglei huanglei@quanjingshuju.com\", \"@DateTime $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\" ], \"php-docblocker.returnGap\": false, \"php-docblocker.classTemplate\": {}, 6. Mysql 通过 + 添加配置，支持自动联想 7. cloudmusic vscode中的可视化的网易云音乐，非常奈斯 8. PHP Debug 通过断点调试来一步步调试代码 9. 删除文件状态栏 \"workbench.editor.showTabs\": false ","description":"","tags":["php","vscode"],"title":"Vscode php配置","uri":"/blog/vscode/config/"},{"categories":["php"],"content":"1. 合并所有元素(使用数组解包) 1 2 3 4 5 6 7  \u003c?php $a = 1; $b = [2, 3]; var_dump(array_merge([$a], $b));//php7.4前  var_dump([$a, ...$b]);//php7.4   2. null 合并运算符 1 2 3 4 5 6  \u003c?php $default = 'a'; $username = $default ?? 'username'; var_dump($username);//php7.0   1 2 3  \u003c?php var_dump(isset($username) ? 'hi' : 'username');//php7.0前   3. 空合并运算符赋值 1 2 3 4 5 6 7 8  \u003c?php $q = isset($q) ? 1 : 2;//php7.4前  $a ??= 1;//php7.4  var_dump($q); var_dump($a);   4. 可为空(Nullable)类型 1 2  php7.1后，参数以及返回值的类型现在可以通过在类型前加上一个问号使之允许为空 当启用这个特性时，传入的参数或者函数返回的结果要么是给定的类型，要么是 null   1 2 3 4 5 6 7 8 9 10  \u003c?php function test(?string $name) { var_dump($name); } test('test'); //\"test\"  test(null); //null  test(); //Uncaught Error: Too few arguments ...   5. 多异常捕获处理 1 2 3 4 5 6  \u003c?php try { // some code  } catch (Exception1 | Exception2 $e) { }   6. list 函数 1 2 3 4 5  $arr = ['apple', 'red']; list($fruit, $color) = $arr; var_dump($fruit, $color);   1 2 3 4 5 6  # 列出他们的其中一个 $arr = ['apple', 'red']; list(, $color) = $arr; var_dump($color);   1 2 3 4 5 6 7 8  # php7.1后可以指定键名 $arr = [ ['id' =\u003e 1, 'val' =\u003e 'val1'], ['id' =\u003e 2, 'val' =\u003e 'val2'], ]; list('id' =\u003e $id, 'val' =\u003e $val) = reset($arr); var_dump($id, $val);   1 2 3 4 5 6 7 8  $arr = [ ['id' =\u003e 1, 'val' =\u003e 'val1'], ['id' =\u003e 2, 'val' =\u003e 'val2'], ]; foreach ($arr as ['id' =\u003e $id, 'val' =\u003e $val]) { var_dump($id, $val); }   7. 箭头函数 1 2 3 4 5 6 7 8  \u003c?php //php7.4前  $demo1 = array_map(function ($val){ return $val * $val; }, [1,2]); //php7.4后  $demo2 = array_map(fn($val) =\u003e $val * $val, [1,2]);   8. 取出数组中的元素 1 2 3 4 5 6 7 8 9 10  \u003c?php $arr = [ ['id' =\u003e 'zx', 'name' =\u003e 'ZX'], ['id' =\u003e 'as', 'name' =\u003e 'AS'], ['id' =\u003e 'qw', 'name' =\u003e 'QW'], ]; # 如何快速取出二维数组对于id的值  var_dump(array_column($arr, 'id'));   9. match 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u003c?php //php8前  switch ($input) { case \"true\": $result = 1; break; case \"false\": $result = 0; break; case \"null\": $result = NULL; break; } //php8后  $result = match($input) { \"true\" =\u003e 1, \"false\" =\u003e 0, \"null\" =\u003e NULL, }; $result = match($input) { \"true\", \"on\" =\u003e 1, \"false\", \"off\" =\u003e 0, \"null\", \"empty\", \"NaN\" =\u003e NULL, }; # match使用的是严格比较(===)，值和类型都要完全相等  # 当input并不能被match中的所有条件满足的时候，match会抛出一个UnhandledMatchError exception   参考文章\n","description":"","tags":["php"],"title":"Clean code","uri":"/blog/php/tips/"},{"categories":["docker"],"content":" 快速搭建在线Vscode,我的电脑是8g Macbook,越来越力不从心了,于是开始从phpstorm转换到Vscode\n 下文需要一点点docker基础 1 2 3 4 5  $ git clone https://github.com/Mitirrli/docker-vscode.git $ cd docker-vscode \u0026\u0026 cp .env.example .env \u0026\u0026 vim .env //复制env文件并修改配置项 $ vim docker-compose.yaml //改成你的文件夹路径   启动项目 1 2 3  # 注: 需要先安装docker和docker-compose $ docker-compose up -d //启动项目,之后就可以通过对应端口进行访问了,如果是云服务器,开启对应防火墙规则即可   参考项目\n","description":"","tags":["docker","vscode"],"title":"Docker Vscode","uri":"/blog/docker/docker-vscode/"},{"categories":["elasticsearch"],"content":"使用docker-compose快速搭建环境 1. 编辑docker-compose文件 1  $ vim docker-compose.yaml   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  version:'3.7'services:elasticsearch:container_name:elasticsearchbuild:context:./elasticsearchargs:- ELK_VERSION=${ELK_VERSION}restart:alwaysenvironment:- \"discovery.type=single-node\"- \"xpack.security.enabled=true\"- bootstrap.memory_lock=true- \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"- ELASTIC_PASSWORD=changemeulimits:memlock:soft:-1hard:-1volumes:- ./data:/usr/share/elasticsearch/dataports:- \"${ELASTICSEARCH_HTTP_PORT}:9200\"networks:- elastickibana:container_name:kibanabuild:context:./kibanaargs:- ELK_VERSION=${ELK_VERSION}restart:alwaysdepends_on:- elasticsearchvolumes:- ./kibana/kibana.yml:/usr/share/kibana/config/kibana.ymlports:- \"${KIBANA_HTTP_PORT}:5601\"networks:- elasticnetworks:elastic:  2. 编辑elasticsearch的Dockerfile 1  $ vim elasticsearch/Dockerfile   1 2 3  ARG ELK_VERSIONFROMdocker.elastic.co/elasticsearch/elasticsearch:${ELK_VERSION}  3. 编辑kibana的Dockerfile 1  $ vim kibana/Dockerfile   1 2 3  ARG ELK_VERSIONFROMdocker.elastic.co/kibana/kibana:${ELK_VERSION}  4. 编辑kibana的配置文件 1  $ vim kibana/kibana.yml   1 2 3 4 5 6 7 8 9 10  server.name:kibanaserver.host:\"0\"elasticsearch.hosts:[\"http://elasticsearch:9200\"]elasticsearch.username:\"elastic\"elasticsearch.password:\"changeme\"i18n.locale:\"zh-CN\"monitoring.ui.container.elasticsearch.enabled:true  5. 增加环境变量 1  $ vim .env   ELK_VERSION=7.9.0 KIBANA_HTTP_PORT=5601 ELASTICSEARCH_HTTP_PORT=9200 使用docker快速搭建elasticsearch和kibana\n","description":"","tags":["docker","elasticsearch","kibana"],"title":"快速搭建单节点elasticsearch和kibana","uri":"/blog/elasticsearch/build/"},{"categories":["mysql"],"content":"1. 首先创建一个数据库 1  CREATE DATABASE function_db;   2. 创建一个用户表 use function_db; CREATE table user( `uid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户id', `name` VARCHAR(5) NOT NULL DEFAULT '' COMMENT '用户姓名', `age` TINYINT(3) NOT NULL DEFAULT 1 COMMENT '用户年龄', PRIMARY KEY (`uid`) ); 3. 插入单条数据 INSERT INTO function_db.user ( name, age ) VALUES ( '张三', 10 ) 4. 插入多条数据 INSERT INTO function_db.user ( name, age ) VALUES ( '张三', 10 ), ( '李四', 20 ) 5. 按规定列添加 # 主键用0或者null代替 INSERT INTO function_db.user VALUES ( NULL, '张三', 10 ), ( NULL, '李四', 20 ) ","description":"","tags":["mysql"],"title":"Mysql 数据库操作","uri":"/blog/mysql/operate/"},{"categories":["kubernetes"],"content":"1. Cronjobs 2. Deployment 3. Service 4. Ingress ","description":"","tags":["kubernetes"],"title":"K8S各种yaml配置","uri":"/blog/kubernetes/yaml/"},{"categories":["git"],"content":"Gitlab版本升级 公司目前gitlab版本是9.5.5,因升级服务器顺道把gitlab也升到最新,这里记录下历程。\n备份Gitlab 1  $ gitlab-rake gitlab:backup:create   执行命令进行备份，将会生成一个命名格式为_gitlab_backup.tar的压缩包\nGitlab升级 升级历程: 9.5.5 -\u003e 9.5.9 -\u003e 9.5.10 -\u003e 10.8.7 -\u003e 11.11.8 -\u003e 12.0.12 -\u003e 12.10.14 -\u003e 13.0.12 -\u003e 13.2.3 按照官网升级顺序依次升级\n下载deb包(*为版本号) 1  $ wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/xenial/main/g/gitlab-ce/gitlab-ce_*-ce.0_amd64.deb   安装deb包 1  $ dpkg -i *.deb   查看版本 1  $ cat /opt/gitlab/embedded/service/gitlab-rails/VERSION   Gitlab恢复 首先关闭服务\n1  $ gitlab-rake gitlab:backup:restore BACKUP 1597233443_2020_08_12_9.3.1   Gitlab 502解决(查看pid) 1  $ gitlab-ctl status   ","description":"","tags":["gitlab"],"title":"Update Gitlab","uri":"/blog/gitlab/update/"},{"categories":["docker"],"content":"快速使用 1 2 3 4 5  $ git clone https://github.com/Mitirrli/docker-compose.git $ cp .env.example .env 之后在项目根目录放置自己代码, 在.docker/nginx/conf.d下放置nginx配置文件即可   环境变量 # Port PHP5_PORT=9005 PHP7_PORT=9007 WEB_PORT=80 REDIS_PORT=6379 # Container PHP5_CONTAINER_NAME=php5 PHP7_CONTAINER_NAME=php7 NGINX_CONTAINER_NAME=web REDIS_CONTAINER_NAME=redis # Version PHP5_VERSION=5.5.38-fpm-alpine PHP7_VERSION=7.1.30-fpm-alpine PHP7REDIS_VERSION=5.3.1 PHP5REDIS_VERSION=5.3.1 REDIS_VERSION=6.0.6-alpine3.12 NGINX_VERSION=latest XLSWRITER_VERSION=1.3.6 SWOOLE_VERSION=4.5.2 # Ini INSTALL_XDEBUG=true INSTALL_REDIS=true INSTALL_XLSWRITER=false INSTALL_SWOOLE=false docker-compose命令 1 2 3 4 5 6 7 8 9 10 11  $ docker-compose up //前台启动 $ docker-compose up -d //后台启动 $ docker-compose stop //暂停容器 $ docker-compose start //启动容器 $ docker-compose down -v //停止并删除容器 $ docker exec -it [container_name] sh //进入容器   开启Xdebug 1 2 3 4 5  1 . 配置 INSTALL_XDEBUG 为true 2 . Preferences -\u003e Set Debug port 9001 3 . Select path mapping   ","description":"","tags":["docker","php"],"title":"Docker 搭建php环境","uri":"/blog/docker/php-environment/"},{"categories":["elasticsearch"],"content":" 几种调用方式\n 1. kibana 控制台 1 2 3 4 5 6  GET /my_index/_search { \"query\": { \"match\": {\"testField\": \"abc\"} } }   2. 命令行 1 2 3 4 5 6 7  $ curl -XGET 'localhost:9200/my_index/_search' -d '{ \"query\" : { \"match\" : { \"testField\" : \"abc\" } } }'   3. php调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  $param1 = [ 'index' =\u003e 'my_index', 'body' =\u003e [ 'query' =\u003e [ 'match' =\u003e [ 'testField' =\u003e 'abc' ] ] ] ]; $param2 = [ 'index' =\u003e 'my_index', 'body' =\u003e '{ \"query\" : { \"match\" : { \"testField\" : \"abc\" } } }' ]; $results = $client-\u003esearch($param1); $results = $client-\u003esearch($param2);   4. 一些常用字段 1 2 3 4 5  $milliseconds = $results['took']; $maxScore = $results['hits']['max_score']; $score = $results['hits']['hits'][0]['_score']; $doc = $results['hits']['hits'][0]['_source'];    请求体查询\n 1. 空查询 1 2 3 4 5 6 7 8 9 10 11  GET /_search {} GET /_search { \"query\": { \"match_all\": {} } } //空查询将返回所有索引库中的所有文档    查询与过滤\n 1. match_all查询 1  { \"match_all\": {}}   2. match查询 1 2 3 4  { \"match\": { \"age\": 26 }} { \"match\": { \"date\": \"2014-09-01\" }} { \"match\": { \"public\": true }} { \"match\": { \"tag\": \"full_text\" }}   3. multi_match查询 1 2 3 4 5 6  { \"multi_match\": { \"query\": \"full text search\", \"fields\": [ \"title\", \"body\" ] } }   4. range查询 1 2 3 4 5 6 7 8  { \"range\": { \"age\": { \"gte\": 20, \"lt\": 30 } } }   5. term查询 1 2 3 4 5 6  //term 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串： { \"term\": { \"age\": 26 }} { \"term\": { \"date\": \"2014-09-01\" }} { \"term\": { \"public\": true }} { \"term\": { \"tag\": \"full_text\" }}   6. terms查询 1 2 3  //terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： { \"terms\": { \"tag\": [ \"search\", \"full_text\", \"nosql\" ] }}   7. exists和missing查询 1 2 3 4 5 6 7 8  //exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性： { \"exists\": { \"field\": \"title\" } } //这些查询经常用于某个字段有值的情况和某个字段缺值的情况。    一些示例\n 1. 布尔请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ curl -XGET 'localhost:9200/my_index/_search' -d '{ \"query\" : { \"bool\" : { \"must\": [ { \"match\" : { \"testField\" : \"abc\" } }, { \"match\" : { \"testField2\" : \"xyz\" } } ] } } }'   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $params = [ 'index' =\u003e 'my_index', 'body' =\u003e [ 'query' =\u003e [ 'bool' =\u003e [ 'must' =\u003e [ [ 'match' =\u003e [ 'testField' =\u003e 'abc' ] ], [ 'match' =\u003e [ 'testField2' =\u003e 'xyz' ] ], ] ] ] ] ]; $results = $client-\u003esearch($params);   2. 既包含过滤器，也包含查询 1 2 3 4 5 6 7 8 9 10 11 12  $ curl -XGET 'localhost:9200/my_index/_search' -d '{ \"query\" : { \"bool\" : { \"filter\" : { \"term\" : { \"my_field\" : \"abc\" } }, \"should\" : { \"match\" : { \"my_other_field\" : \"xyz\" } } } } }'   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $params = [ 'index' =\u003e 'my_index', 'body' =\u003e [ 'query' =\u003e [ 'bool' =\u003e [ 'filter' =\u003e [ 'term' =\u003e [ 'my_field' =\u003e 'abc' ] ], 'should' =\u003e [ 'match' =\u003e [ 'my_other_field' =\u003e 'xyz' ] ] ] ] ] ]; $results = $client-\u003esearch($params);   参考文档\n","description":"","tags":["php","elasticsearch"],"title":"使用elasticsearch-php扩展","uri":"/blog/elasticsearch/search-operation/"},{"categories":["linux"],"content":"1. 命令格式  scp [参数] [原路径] [目标路径]\n 2. 命令参数 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 3. 使用示例 1. 从远处复制文件到本地目录 1  $ scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/   2. 从远处复制到本地 $ scp -r root@10.6.159.147:/opt/soft/test /opt/soft/ 3. 上传本地文件到远程机器指定目录 $ scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest 4. 上传本地目录到远程机器指定目录 $ scp -r /opt/soft/test root@10.6.159.147:/opt/soft/scptest 参考文章\n","description":"","tags":["linux","copy"],"title":"Scp 跨机远程拷贝","uri":"/blog/linux/scp/"},{"categories":["elasticsearch"],"content":"1. FROM + SIZE 方案 1 2 3  from 指明了分页查询返回的结果的起始位置，而size参数则指明了分页查询的页容量 原理: 比如查询第二页的数据，每页有10条数据，就是查询前20条数据，然后截断前10条，只返回后面10条   1 2 3  存在的问题: 1. 分页的偏移值越大，执行分页查询时间越长 2. from + size 不能超过索引的 index.max_result_window 值   1 2 3 4 5 6 7 8 9 10 11 12  POST /_search { \"from\": 30, \"size\": 10 } GET /_search { \"from\": 30, \"size\": 10 } //两种方式均支持   2. SCROLL 深分页 1 2  该查询实现类似于消息消费的机制，首次查询的时候会在内存中保存一个历史快照以及游标(scroll_id)，记录当前消息查询的终止位置，下次查询的时候将基于游标进行消费 性能良好，维护成本高，在游标失效前，不会更新数据，不够灵活，一旦游标创建size就不可改变，适用于大量数据导出或者索引重建   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  $client = ClientBuilder::create()-\u003ebuild(); $params = [ 'scroll' =\u003e '30s', // how long between scroll requests. should be small! 'size' =\u003e 50, // how many results *per shard* you want back 'index' =\u003e 'my_index', 'body' =\u003e [ 'query' =\u003e [ 'match_all' =\u003e new \\stdClass() ] ] ]; // Execute the search // The response will contain the first batch of documents // and a scroll_id $response = $client-\u003esearch($params); // Now we loop until the scroll \"cursors\" are exhausted while (isset($response['hits']['hits']) \u0026\u0026 count($response['hits']['hits']) \u003e 0) { // ** // Do your work here, on the $response['hits']['hits'] array // ** // When done, get the new scroll_id // You must always refresh your _scroll_id! It can change sometimes $scroll_id = $response['_scroll_id']; // Execute a Scroll request and repeat $response = $client-\u003escroll([ 'body' =\u003e [ 'scroll_id' =\u003e $scroll_id, //...using our previously obtained _scroll_id 'scroll' =\u003e '30s' // and the same timeout window ] ]); }   3. Search After 1 2 3  原理: 使用历史条件过滤掉数据，通过上一页的结果帮助检索下一页，通过将sort值与search_after参数一起使用，以开始返回在这个结果列表之后的任何文档 注意: 当使用search_after参数时，from的值必须被设为0或者-1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  $ curl -XGET \"http://localhost:9200/bank/_search\" -H 'Content-Type: application/json' -d' { \"size\": 10, \"query\": { \"match\" : { \"address\" : \"place\" } }, \"sort\": [ {\"balance\": \"asc\"}, {\"_id\": \"desc\"} ] }' $ curl -XGET \"http://localhost:9200/bank/_search\" -H 'Content-Type: application/json' -d' { \"size\": 10, \"query\": { \"match\" : { \"address\" : \"place\" } }, \"search_after\": [4652, \"590\"], \"sort\": [ {\"balance\": \"asc\"}, {\"_id\": \"desc\"} ] }'   参考文章\n参考文章\n参考文档\n","description":"","tags":["php","elasticsearch"],"title":"Elasticsearch 分页","uri":"/blog/elasticsearch/page/"},{"categories":["kubernetes"],"content":"K8S 节点状态无法调度,状态为 SchedulingDisabled 解决方案(*为 ip):\n1  $ kubectl patch no * -p '{\"spec\": {\"unschedulable\": false}}'   Back-off restarting failed container 根据 Describe Pod,pod 内的 Container 已完成.但是 Pod 的生命周期非常短,要使 Pod 持续运行,您必须指定一个永远不会完成的任务.\nK8S 挂载单个文件 使用 subPath,部分代码如下:\n1 2 3 4  volumeMounts:- mountPath:/var/www/html/.envname:envsubPath:.env  K8S 获取崩溃容器的应用日志 1 2 3 4  如果你的容器重启,kubectl logs命令将显示当前容器的日志。 如果你想看前一个容器的日志,添加--previous kubectl logs mypod --previous   增加滚动更新 minReadySeconds: 5 strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate ","description":"","tags":["kubernetes"],"title":"K8S遇到的问题记录","uri":"/blog/kubernetes/question-record/"},{"categories":["regex"],"content":"推荐一个在线regex平台\n一、基础用法 1. 直接匹配字符串  123\n 123 (匹配) 2. ^代表整段字符串的开头，$代表整段字符串的结尾  ^123$\n 123 (匹配) 1234 3. 中括号只能匹配一个字符  ^[abc]$\n a (匹配)  ^[a-zA-Z]$\n a (匹配) 4. 取反^ (该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合)  ^[^abca-z]$\n d (匹配) 5. 匹配字母的数目  ^[a-zA-Z]{3}$\n abc (匹配)  ^[a-zA-Z]{3,}$\n abcdef (匹配) //至少匹配3次  ^[a-zA-Z]{3,6}$\n abcdef (匹配) //最少匹配3次且最多匹配6次 6. 匹配任意字符(回车除外) .  ^.{3,6}$\n abc (匹配) //除换行符的任意字符 7. 匹配数字  \\d\n // \\d与[0-9]等效 8. 匹配非数字  \\D\n // \\D与[^0-9]等效 9. 匹配任意字符  [\\d\\D]{0,}\n 123 612334 abc (匹配) 10. 匹配字母数字下划线  \\w\n // \\w与[a-zA-z0-9_]等效 11. 匹配非字母数字下划线  \\W\n // \\W与[^a-zA-z0-9_]等效 12. 匹配所有空白符  \\s\n // \\s与[\\r\\n\\t\\f\\v ]等效 13. 匹配非所有空白符  \\S\n // \\S与[^\\r\\n\\t\\f\\v ]等效 14. 匹配 0 次-1 次  ?\n // 匹配前面的子表达式零次或一次 // ?与{0,1}等效 15. 匹配 0 次-无穷次      // 匹配前面的子表达式零次到无穷次 // *与{0,}等效 16. 匹配 1 次-无穷次      // 匹配前面的子表达式一次到无穷次 // +与{1,}等效 17. 转义  \\\n // .表示除换行符任意字符，表示.需要用\\. 二、Group 1. 使用()匹配文本 ^([a-zA-Z0-9][\\w.]*)@[a-zA-Z0-9]*.com$ 2. 在(后增加?\u003c\u003e给组命名 1 2 3 4 5 6 7 8 9  \u003c?php preg_match( '/^(?\u003cfirst\u003e[a-zA-Z0-9][\\w.]*)@(?\u003csecond\u003e[a-zA-Z0-9]*).com$/', 'phper@gmail.com', $result ); var_dump($result);   array(5) { [0]=\u003e string(15) \"phper@gmail.com\" [\"first\"]=\u003e string(5) \"phper\" [1]=\u003e string(5) \"phper\" [\"second\"]=\u003e string(5) \"gmail\" [2]=\u003e string(5) \"gmail\" } 3. 匹配重复的字符  ^(\\d\\d)\\1$\n // \\1表示第一个被匹配的组 1212 (匹配)  ^(?\\d\\d)\\k$\n // \\k 表示匹配组名 1212 (匹配) 4. ?=  run(?=[\\d+])\n // run123run12567 // exp1(?=exp2)：查找 exp2 前面的 exp1 5. ?\u003c=  (?\u003c=[\\d+])[a-z]+\n // 123accc1111d // (?\u003c=exp2)exp1：查找 exp2 后面的 exp1。 6. ?!  woyong(?!qq)\n woyongqq woyongdd (匹配) // exp1(?!exp2)：查找后面不是 exp2 的 exp1。 7.?\u003c!  (?\u003c![qq*])ilove\n qqilove wxilove (匹配) (?\u003c!exp2)exp1：查找前面不是 exp2 的 exp1。 参考资料\n","description":"","tags":["regex"],"title":"正则表达式","uri":"/blog/regex/usage/"},{"categories":["docker"],"content":"1. 单机意味着该网络只能在单个Docker主机上运行, 并且只能与所在Docker主机上的容器进行连接. 2. 桥接意味着这是802.1.d桥接的一种实现(二层交换机). 3. 每个docker主机都有一个默认的单机桥接网络, 在Linux上网络名称为bridge, 除非通过命令行创建容器时指定参数--network, 否则默认情况下, 新创建的容器都会连接该网络. 在Linux主机上, Docker网络由Bridge驱动创建, 而Bridge底层是基于Linux Bridge技术. 默认的 \"bridge\" 网络被映射到内核中为 \"docker0\" 的Linux网桥. 1 2 3 4 5 6 7 8  # 查看docker网络 $ docker network ls # 查看docker网络详细信息 $ docker network inspect bridge # 默认的 \"bridge\" 网络被映射到内核中 \"docker0\" 的Linux网桥 $ docker network inspect bridge | grep bridge.name   创建一个单机桥接网络 1 2  # --driver, -d 驱动程序管理网络 $ docker network create -d bridge localnet   1 2 3 4 5 6 7  # 查网桥 $ brctl show bridge name\tbridge id\tSTP enabled\tinterfaces br-af67059cd875\t8000.0242002faa2a\tno br-f3899931862a\t8000.02426061dc5d\tno\tveth5e503b2 docker0\t8000.0242dfe1b585\tno   1 2  # 创建一个新容器, 接入到桥接网络localnet中 $ docker run -d --name c1 --network localnet alpine sleep 1d   1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 查看接入状况 $ docker network inspect localnet \"Containers\": { \"fef8306b1fa75eab73e4976f9a546bbba19e2ed94e6e8f1e71d85c8f386143d0\": { \"Name\": \"c1\", \"EndpointID\": \"cc7395dc34c3fd618cdebf6c25758525c19a5f5781c113c55f066e9d8528e630\", \"MacAddress\": \"02:42:ac:17:00:02\", \"IPv4Address\": \"172.23.0.2/16\", \"IPv6Address\": \"\" } } # 此时 \"c1\" 容器此时已经位于桥接网络localnet之上   1 2 3 4 5 6 7  # 再次查看网桥 $ brctl show bridge name\tbridge id\tSTP enabled\tinterfaces br-af67059cd875\t8000.0242002faa2a\tno\tvethabd87e7 br-f3899931862a\t8000.02426061dc5d\tno\tveth5e503b2 docker0\t8000.0242dfe1b585\tno    如果在相同的网络继续接入其他容器, 那么在新接入容器是可以通过 “c1” 的容器名称来ping通的. 这是因为新容器都注册到了指定的 Docker DNS服务. Linux 默认的 Bridge网络是不支持通过 Docker DNS服务进行域名解析的, 字定义桥接网络可以.\n 1 2 3 4 5  # 创建 \"c2\" 容器, 也接入localnet $ docker run -it --name c2 --network localnet alpine sh $ ping c1    这是因为 c2 容器运行了一个本地 DNS 解析器, 该解析器将请求转发到了Docker内部DNS服务器中. DNS服务器中记录了容器启动时通过 –name或者–net-alias参数追定的名称与容器之间的映射关系.\n 参考书籍: 深入浅出Docker ","description":"","tags":["docker","network"],"title":"Docker 单机桥接网络","uri":"/blog/docker/network/"},{"categories":["php"],"content":"1. 关于 Git Hooks  和其它版本控制系统一样，Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。\n  钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。把一个正确命名（不带扩展名）且可执行的文件放入 .git 目录下的 hooks 子目录中，即可激活该钩子脚本。\n 2. 提交工作流钩子 1. pre-commit pre-commit 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit --no-verify 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。 2. post-commit 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 git log -1 HEAD 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。 3. pre-push pre-push 钩子会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。 4. post-merge 在 git merge 成功运行后，post-merge 钩子会被调用。 你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。 这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。 3. 安装composer-git-hooks  \"extra\": { \"hooks\": { \"pre-commit\": \"composer check-style\", \"pre-push\": [ \"composer test\", \"composer cs-fix\" ] } }, \"scripts\": { \"post-update-cmd\": [ \"cghooks update\" ], \"post-merge\": \"composer install\", \"post-install-cmd\": [ \"cghooks add --ignore-lock\", \"cghooks update\" ], \"check-style\": \"php-cs-fixer fix --using-cache=no --diff --config=.php_cs --dry-run --ansi\", \"cs-fix\": \"php-cs-fixer fix --using-cache=no --config=.php_cs --ansi\", \"test\": \"vendor/bin/phpunit --colors=always --testdox\" } 1  $ composer require --dev brainmaestro/composer-git-hooks   ","description":"","tags":["git","php","composer"],"title":"Composer Git Hooks","uri":"/blog/php/composer-git-hooks/"},{"categories":["docker"],"content":"1. 安装扩展, 以 redis 为例: 1 2 3 4 5 6 7  RUN curl -L -o /tmp/redis.tar.gz https://github.com/phpredis/phpredis/archive/{VERSION}.tar.gz \\  \u0026\u0026 tar xfz /tmp/redis.tar.gz \\  \u0026\u0026 rm -r /tmp/redis.tar.gz \\  \u0026\u0026 mkdir -p /usr/src/php/ext \\  \u0026\u0026 mv phpredis-{VERSION} /usr/src/php/ext/phpredisRUN docker-php-ext-install phpredis  2. 更换 ALPINE 的源 1 2  RUN echo http://mirrors.aliyun.com/alpine/v3.12/main \u003e /etc/apk/repositories \\  \u0026\u0026 echo http://mirrors.aliyun.com/alpine/v3.12/community \u003e\u003e /etc/apk/repositories  3. 更换 UBUNTU 的源 1  RUN sed -i 's/security-cdn.debian.org/mirrors.tuna.tsinghua.edu.cn/' /etc/apt/sources.list  4. 安装 composer 1 2 3  RUN wget https://mirrors.aliyun.com/composer/composer.phar -O /usr/local/bin/composer \\  \u0026\u0026 chmod a+x /usr/local/bin/composer \\  \u0026\u0026 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer  ","description":"","tags":["docker","php"],"title":"Docker - php容器安装扩展","uri":"/blog/docker/extension-php/"},{"categories":["php"],"content":"本地调试组件 1. 目录结构 在项目根目录创建一个packagist包，用来放置组件包，加入到.gitignore文件中。通过path的方式，让composer将test组件作为依赖加载到project中 1 2 3 4 5 6 7 8 9  . ├── packagist │ └── test │ └── src └── project ├── app ├── config ├── runtime └── vendor   2. 创建新的组件 1 2 3 4 5 6 7 8 9  $ cd packagist $ mkdir -p test/src \u0026\u0026 cd test $ composer init //初始化git仓库,填写对应的信息后会生成对应的composer.json文件 $ composer i $ vim composer.json   3. 修改composer内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  { \"name\": \"qjdata/test\", \"authors\": [ { \"name\": \"Huanglei\", \"email\": \"huanglei@quanjingshuju.com\" } ], \"require\": {}, \"autoload\": { \"psr-4\": { \"Qwertyuiop\\\\\": \"./src\" } } }   4. 增加测试类 1 2 3  $ cd src $ vim Test.php   1 2 3 4 5 6 7 8 9 10 11  \u003c?php namespace Qwertyuiop; class Test { public function test() { echo 'qwerty'; } }   5. 在项目中使用未发布的组件包 1 2 3 4 5 6  \"repositories\": { \"qjdata/test\": { \"type\": \"path\", \"url\": \"./packagist/test\" } }   1 2 3  $ composer require qjdata/test dev-master //现在就实现了在子项目更改代码,主项目代码也动态改变的目的 $ cd /var/www/html/yaoxiebang-php-skeleton/vendor/ \u0026\u0026 ls -l qjdata //test -\u003e ../../packagist/test   1  var_dump((new Test())-\u003etest()); //可以看到输出了\"qwerty\"   上传组件至私有gitlab 1. 在gitlab中创建一个项目，命名为test 2. 接下来我们把上篇packagist下的test目录传到gitlab中 1 2 3 4 5 6 7  $ cd /var/www/html/yaoxiebang-php-skeleton/packagist/test $ git init $ git remote add origin \u003c远程地址\u003e $ git add . \u0026\u0026 git commit -m \"Initial commit\" \u0026\u0026 git push -u origin master   3. 使用私有gitlab作为源(修改composer.json) 使用ssh地址，需要将克隆仓库用户的id_rsa.pub文件添加到Gitlab 1 2 3 4 5 6  \"repositories\": { \"qjdata/test\": { \"type\": \"vcs\", \"url\": \"\u003curl\u003e\" } }   1  $ composer require qjdata/test dev-master   1  var_dump((new Test())-\u003etest()); //可以看到输出了\"qwerty\"   ","description":"","tags":["php","composer","组件化开发","gitlab"],"title":"Composer 组件化开发","uri":"/blog/php/composer-component/"},{"categories":["git"],"content":" 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立\n 添加子模块 1 2 3  # 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对URL来添加新的子模块 $ git submodule add ... //默认情况下,子模块会将子项目放到一个与仓库同名的目录中,如果你想要放到其他地方,那么可以在命令结尾添加一个不同的路径   1 2 3  此时.gitmodules文件保存了项目 URL 与已经拉取的本地目录之间的映射。 修改子模块url: git config submodule.\u003c模块名\u003e.url \u003c私有URL\u003e 来覆盖这个选项的值   克隆含有子模块的项目 1 2 3 4 5  $ git clone \u003curl\u003e $ git submodule init //初始化本地配置文件 $ git submodule update //从该项目中抓取所有数据并检出父项目中列出的合适的提交   1 2 3 4  $ git clone --recurse-submodules \u003curl\u003e //传递--recurse-submodules选项,它就会自动初始化并更新仓库中的每一个子模块,包括可能存在的嵌套子模块 # 如果你已经克隆了项目但忘记了--recurse-submodule,那么可以运行git submodule update --init将git submodule init和git submodule update合并成一步 # 如果还要初始化、抓取并检出任何嵌套的子模块,请使用简明的git submodule update --init --recursive   在主项目更新子模块 1 2 3 4 5  $ git submodule update --remote \u003c模块名\u003e $ git config -f .gitmodules submodule.\u003c模块名\u003e.branch \u003c分支名\u003e //设置模块默认的分支 # 如果不用 -f .gitmodules 选项,那么它只会为你做修改   更新包含子模块的项目 1 2 3 4  $ git submodule update --init --recursive //如果MainProject提交了你刚拉取的新子模块,应该在 git submodule update 后面添加--init选项,如果子模块有嵌套的子模块,则应使用--recursive选项 # 如果你想自动化此过程,那么可以为 git pull 命令添加--recurse-submodules选项 # 如果你想让Git总是以--recurse-submodules拉取,可以将配置选项submodule.recurse设置为true.此选项会让Git为所有支持--recurse-submodules的命令使用该选项(除clone以外)   子模块遍历 1 2 3  # 有一个foreach子模块命令,它能在每一个子模块中运行任意命令 $ git submodule foreach 'git stash'   增加子模块别名 1 2 3  $ git config alias.sdiff '!'\"git diff \u0026\u0026 git submodule foreach 'git diff'\" $ git config alias.spush 'push --recurse-submodules=on-demand' $ git config alias.supdate 'submodule update --remote --merge'   删除子模块 1 2 3  $ git submodule deinit \u003c子模块\u003e //逆初始化模块 $ git rm --cached \u003c子模块\u003e //删除.gitmodules中记录的模块信息(--cached选项清除.git/modules中的缓存) $ git commit -m 'comment'   git官方文档\n","description":"","tags":["git"],"title":"Git 子模块","uri":"/blog/git/submodule/"},{"categories":["php"],"content":"1. 设置时区  date_default_timezone_set — 设定用于一个脚本中所有日期时间函数的默认时区\n date_default_timezone_set ( string $timezone_identifier ) : bool 用法 1  date_default_timezone_set('Asia/Shanghai');    ini_set — 为一个配置选项设置值，这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。\n 用法 1  ini_set('date.timezone','Asia/Shanghai');   支持使用ini_set修改的参数附录\n2. 生成一个格式化的时间  date — 格式化一个本地时间／日期\n date ( string $format [, int $timestamp ] ) : string    format 字符 描述 返回值示例     天 — —   d 一个月中的第几天，有前导0的2位数字 从01到31   D 3个字符表示的星期几 3个字符表示的星期几，从Mon到Sun   j 一个月中的第几天，无前导0 从1到31   N ISO-8601 规定的数字表示的星期几 从1(表示星期一)到7(表示星期日)   w 数字表示的星期几 从0(星期日)到6(星期六)   z 一年中的第几天，从0开始计数 从 0 到 365   周 — —   W ISO-8601规范的一年中的第几周，周一视为一周开始。 42(本年第42周)   月 — —   m 带有0前导的数字表示的月份 从01到12   n 月份的数字表示，无前导0 从1到12   t 给定月份中包含多少天 从28到31   年 — —   Y 4位数字的年份 1999或2003   y 2位数字的年份 99或03   时间 — —   a 上午还是下午，2位小写字符 am或pm   A 上午还是下午，2位大写字符 AM或PM   g 小时，12时制，无前导0 从1到12   G 小时，24时制，无前导0 从0到23   h 小时，12时制，有前导0的2位数字 从01到12   H 小时，24时制，有前导0的2位数字 从00到23   i 分钟，有前导0的2位数字 从00到59   s 秒，有前导0的2位数字 从00到59   完整的日期/时间 — —   c ISO 8601日期及时间 2004-02-12T15:19:21+00:00   U 时间戳，以秒为单位 1539100800    参考php手册\n3. 将时间转换为时间戳  strtotime — 将任何字符串的日期时间描述解析为 Unix 时间戳\n 用法 1 2 3 4  strtotime('+1 day'); strtotime(\"+1 week 2 days 4 hours 2 seconds\"); strtotime(\"next Thursday\"); strtotime(\"last Monday\");   常用用法 1 2 3 4  strtotime(date('Y-m-d')); strtotime('+1 day', strtotime(date('Y-m-d'))); strtotime(\"first day of next month\", strtotime(\"2017-01-31\")); strtotime(\"last day of last month\", strtotime(\"2017-03-31\"));   注意 1 2 3 4 5 6 7 8  var_dump(date(\"Y-m-d\", strtotime(\"-1 month\", strtotime(\"2017-03-31\")))); //输出2017-03-03 var_dump(date(\"Y-m-d\", strtotime(\"+1 month\", strtotime(\"2017-08-31\")))); //输出2017-10-01 var_dump(date(\"Y-m-d\", strtotime(\"next month\", strtotime(\"2017-01-31\")))); //输出2017-03-03 var_dump(date(\"Y-m-d\", strtotime(\"last month\", strtotime(\"2017-03-31\")))); //输出2017-03-03   解决方案 1 2 3 4 5 6 7 8  var_dump(date(\"Y-m-d\", strtotime(\"last day of -1 month\", strtotime(\"2017-03-31\")))); //输出2017-02-28 var_dump(date(\"Y-m-d\", strtotime(\"first day of +1 month\", strtotime(\"2017-08-31\")))); //输出2017-09-01 var_dump(date(\"Y-m-d\", strtotime(\"first day of next month\", strtotime(\"2017-01-31\")))); //输出2017-02-01 var_dump(date(\"Y-m-d\", strtotime(\"last day of last month\", strtotime(\"2017-03-31\")))); //输出2017-02-28   令人困惑的strtotime\n","description":"","tags":["php"],"title":"Php 部分时间函数","uri":"/blog/php/time/"},{"categories":["docker"],"content":"1. FROM FROM 必须 是 Dockerfile 中第一条非注释命令, tag 或 digest 是可选的 2. RUN RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 --no-cache 参数 3. COPY COPY 指令将从构建上下文目录中 \u003c源路径\u003e 的文件/目录复制到新的一层的镜像内的`\u003c目标路径\u003e`位置 \u003c目标路径\u003e可以是容器内的绝对路径，也可以是相对于工作目录的相对路径(工作目录可以用 WORKDIR 指令来指定) 使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候 COPY 命令区别于 ADD 命令的一个用法是在 multistage 场景下 4. Add 除了不能用在 multistage 的场景下，ADD 命令可以完成 COPY 命令的所有功能 解压压缩文件并把它们添加到镜像中 WORKDIR /app ADD nickdir.tar.gz . 5. Env 设置环境变量, 后面的其它指令都可以直接使用这里定义的环境变量 ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" // .env # Port PHP_CONTAINER_NAME=php PHP_VERSION={???}-fpm-alpine // docker-compose services: php: container_name: ${PHP_CONTAINER_NAME} build: context: .docker/php args: - PHP_VERSION=${PHP_VERSION} ... // Dockerfile ARG PHP_VERSION FROM php:${PHP_VERSION} 6. EXPOSE EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。 好处: 一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射； 另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口 要将 EXPOSE 和在运行时使用 -p \u003c宿主端口\u003e:\u003c容器端口\u003e 区分开来。 -p，是映射宿主端口和容器端口, 换句话说，就是将容器的对应端口服务公开给外界访问。 而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 7. VOLUME 格式为： VOLUME [\"\u003c路径 1\u003e\", \"\u003c路径 2\u003e\"...] VOLUME \u003c路径\u003e 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中 在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 # 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化 VOLUME /data # 当然，运行时可以覆盖这个挂载设置，在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 docker run -d -v mydata:/data xxxx 8. WORKDIR 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 RUN cd /app RUN echo \"hello\" \u003e world.txt 第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。 而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令 9. LABEL LABEL 指令用来给镜像以键值对的形式添加一些元数据 LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... 指定后可以通过docker inspect查看： docker inspect ($images) \"Labels\": { }, 10. CMD 与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 11. ENTRYPOINT 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： \u003cENTRYPOINT\u003e \"\u003cCMD\u003e\" 参考文章\n参考文章\n","description":"","tags":["docker","Dockerfile"],"title":"DockerFile 指令","uri":"/blog/docker/docker-file/"},{"categories":["nginx"],"content":"1. location 配置  语法规则： location [=|~|~*|^~] /uri/ { … }\n 1 2 3 4 5 6  = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则 / 通用匹配，任何请求都会匹配到   2. 防止用户访问某些隐私文件 # 禁止用户访问.env或其他文件 location ~ /\\. { deny all; } # 禁止用户访问某些后缀的文件 location ~\\.(json|lock|yml|yaml) { deny all; } 3. 反向代理 location / { proxy_pass https://www.baidu.com; } 4. 负载均衡 实现负载均衡：\n 轮询 RR - 默认 每个请求按时间顺序逐一分配到不同的后端服务器, 如果后端服务器 down 掉, 能自动剔除.  upstream balanceServer { server balance1.com; server balance2.com; } server { listen 80; server_name test.me; location / { proxy_pass http://balanceServer; } } 权重 指定轮询几率, weight 和访问比率成正比, 用于后端服务器性能不均的情况  upstream balanceServer { server balance1.com weight=3; server balance2.com weight=7; } server { listen 80; server_name test.me; location / { proxy_pass http://balanceServer; } } IP hash 当我们的程序不是无状态的时候(采用 session 保存数据), 那么跳转到另外一台服务器的时候就需要重新登录了, IP hash 的每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。  upstream balanceServer { ip_hash; server balance1.com; server balance2.com; } server { listen 80; server_name test.me; location / { proxy_pass http://balanceServer; } } 5. 获取反向代理真实 ip # 通过设置header, 之后就可以在请求头x-real-ip获取真实ip proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 6. 504 Gateway Time-out # 调节 proxy_read_timeout 和 proxy_send_timeout 至合适数值即可 7. 调整运行工作进程数量 # 运行工作进程个数一般设置CPU的核心或者核心数x2 worker_processes 2; ","description":"","tags":["nginx"],"title":"Nginx配置","uri":"/blog/nginx/configuration/"},{"categories":["linux"],"content":" 为了高效的使用Linux系统，使用Linux命令是必不可少的，有很多常用的Linux命令更是要必须掌握的\n 1. uptime  uptime(选项)\n 1 2 3 4 5 6 7  # uptime命令可以显示的信息显示依次为:现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载 $ uptime 7:41 up 17:20, //系统当前时间,主机已运行时间,时间越大,说明你的机器越稳定 2 users, //用户总连接数 load averages: 3.86 3.73 3.33 //统计最近1,5,15分钟的系统平均负载(统计最近1,5,15分钟的系统平均负载)   2. tail  tail(选项)(指定要显示尾部内容的文件列表)\n 1 2 3 4 5 6 7  $ tail -n 3 \u003cfile\u003e //-n 指定显示末尾的n行,默认为10行 $ tail +20 \u003cfile\u003e //显示文件file的内容,从第20行至文件末尾 $ tail -c 10 \u003cfile\u003e //-c 指定显示的字符 $ tail -f \u003cfile\u003e //显示文件最新追加的内容   3. find  find(选项)(查找文件的起始目录)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ find . -name *.md //查找当前目录下以md结尾的文件 $ find . -name 'linux' //查找当前目录下所有包含'linux'关键字的文件 $ find / ! -name \"*.txt\" //找出/下不是以.txt结尾的文件 $ find . -type 类型参数(f 普通文件,l 符号连接,d 目录,c 字符设备,b 块设备,s 套接字,p Fifo) $ find . -type f -name \"*.txt\" -delete //删除当前目录下所有.txt文件 $ find . -type f -perm 777 //当前目录下搜索出权限为777的文件 $ find . -type f -user \u003cuser\u003e //找出当前目录用户拥有的所有文件 $ find . -type f -group \u003cgroup\u003e //找出当前目录用户组拥有的所有文件   4. wc  wc(选项)(文件列表)\n 1 2 3 4 5 6 7 8 9 10 11  # 利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称,或是所给予的文件名为“-”,则wc指令会从标准输入设备读取数据 $ wc -c \u003cfiles\u003e //显示Bytes数 $ wc -l \u003cfiles\u003e //显示列数 $ wc -w \u003cfiles\u003e //显示字数 # wc -l 可以配合｜进行统计（例如可以统计文件的行数，进程的个数） # ps -ef | grep php | wc -l # cat test.txt | grep 90 | wc -l   5. grep  grep是一种强大的文本搜索工具,它能使用正则表达式搜索文本,并把匹配的行打印出来,文件夹的话需要递归搜索-R\n 1 2 3 4 5 6 7  $ grep \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //文件中查找 $ grep -c \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //统计文件或者文本中包含匹配字符串的行数 $ grep -E \"[1-9]+\" //使用正则表达式 -E 匹配 $ grep -n \"match_pattern\" \u003cfile1\u003e \u003cfile2\u003e //在显示符合范本样式的那一列之前,标示出该列的编号   6. lsof  lsof命令用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行\n 1 2 3 4 5 6 7  $ lsof -i:\u003cport\u003e //列出谁在使用某个端口 $ lsof -i udp:\u003cport\u003e //列出谁在使用某个特定的udp端口 $ lsof -i tcp:\u003cport\u003e //列出谁在使用某个特定的tcp端口 $ lsof -u \u003cusername\u003e //列出某个用户打开的文件信息   7. ps  ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的\n 1 2 3 4 5  $ ps -A //显示所有进程信息 $ ps -u root //显示指定用户信息 $ ps -ef //显示所有进程信息,连同命令行   8. df  df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息\n 1 2 3  $ df -h //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高 $ df -a //查看全部文件系统   9. du  du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的\n 1 2 3 4 5 6 7 8 9  $ du -h \u003cfile\u003e //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高 $ du -c \u003cfile\u003e //使用-c[--total]除了显示个别目录或文件的大小外,同时也显示所有目录或文件的总和 $ du --max-depth=\u003cnum\u003e \u003cfile\u003e //设置最大深度 $ du -sh \u003cfile\u003e //仅显示总计,只列出最后加总的值 $ du --exclude=\u003cdir\u003e //--exclude=\u003c目录或文件\u003e 略过指定的目录或文件   10. ln  ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用\"-s\"选项\n 1 2 3 4 5 6 7 8 9 10  # Linux链接分两种,一种被称为硬链接(Hard Link),另一种被称为符号链接(Symbolic Link).默认情况下,ln命令产生硬链接 $ ln -s //对源文件建立符号连接,而非硬连接 # 对硬链接有如下限制: # 1. 不能对目录文件做硬链接 # 2. 不能在不同的文件系统之间做硬链接,链接文件和被链接文件必须位于同一个文件系统中 # 符号链接没有硬链接的限制,可以对目录文件做符号链接,也可以在不同文件系统之间做符号链接 # 用ln -s命令建立符号链接时,源文件最好用绝对路径名,这样可以在任何工作目录下进行符号链接.而当源文件用相对路径时,如果当前的工作路径与要创建的符号链接文件所在路径不同,就不能进行链接   可以参考这篇文章’软链接’和’硬链接’的区别\n11. ls  ls命令用来显示目标列表\n 1 2 3 4 5  $ ls -a //显示所有档案及目录(显示隐藏文件) $ ls -i //显示文件索引节点号(inode).一个索引节点代表一个文件[具有相同的索引节点(inode)号的两个文本本质上是同一个文件(除文件名不同外)] $ ls -l //以长格式显示目录下的内容列表.输出的信息从左到右依次包括文件名,文件类型,权限模式,硬连接数,所有者,组,文件大小和文件的最后修改时间等 $ ls -t //最近修改的文件显示在最上面 $ ls -h //使用-h[--human-readable]选项以K,M,G为单位来显示,可读性高   12. mkdir  mkdir命令用来创建目录。该命令创建由dirname命名的目录。如果在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名\n 1 2  $ mkdir -m 755 /usr/test //建立目录的同时设置目录的权限 $ mkdir -p /usr/test //若所要建立目录的上层目录目前尚未建立,则会一并建立上层目录   ","description":"","tags":["linux"],"title":"Linux 常用命令","uri":"/blog/linux/script/"},{"categories":["mysql"],"content":"1 2 3 4 5 6  binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以\"事务\"的形式保存在磁盘中 作用主要有： 1. 复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的 2. 数据恢复：通过mysqlbinlog工具恢复数据 3. 增量备份   1  它包含所有更新数据的语句，他还包含语句那些所有潜在的可能更新的语句(例如一个不匹配任何行的删除语句)。二进制日志还包含信息更新数据的每个语句需要多长时间   获取当前二进制日志列表 1  $ SHOW BINARY LOGS;   指定数据库 1  默认情况下，binlog会显示所有的内容，太过于杂乱。使用 -d(--database) 选项，可以指定一个数据库名称，将只显示在该数据库上所发生的事件   查看特定开始时间 1  --start-datetime   查看特定结束时间 1  --stop-datetime   将条目截止到一个特定的位置 1  --stop-position   1 2 3 4 5 6 7 8  使用base64-output选项，可以控制输出语句何时是输出base64编码的BINLOG语句。以下是base64输出设置的可能值： 1. never 2. always 3. decode-rows 4. auto（默认） 5. never：当指定如下所示的“never”时，它将在输出中显示base64编码的BINLOG语句。 decode-rows：这个选项将把基于行的事件解码成一个SQL语句，特别是当指定-verbose选项(-v)时，如下所示。   示例: 1 2 3  $ mysqlbinlog --database \u003cdb\u003e --base64-output=decode-rows --start-datetime='2019-05-18 05:17:35' --stop-datetime='2019-05-18 05:55:55' --stop-position=177687190 -v mysql-bin.005061 \u003e 1.sql $ mysqlbinlog -R -h \u003chost\u003e\u003e -u \u003cuser\u003e -p --database \u003cdb\u003e --base64-output=decode-rows --start-datetime='2019-05-18 05:17:35' --stop-datetime='2019-05-18 05:55:55' --stop-position=177687190 -v mysql-bin.005061   参考文章\n","description":"","tags":["mysql"],"title":"Mysql Binlog","uri":"/blog/mysql/binlog/"},{"categories":["linux"],"content":" vim 一共有四种模式，分别是正常模式、插入模式、命令模式、可视模式\n 1. 正常模式 启动vim后默认处于正常模式。不论位于什么模式，按下\u003cEsc\u003e键(有时需要按两下）都会进入正常模式。 2. 插入模式 在正常模式中按下i, I, a, A等键，会进入插入模式。现在只用记住按i键会进行插入模式。在插入模式中，击键时会写入相应的字符。 3. 命令模式 在正常模式中，按下:（英文冒号）键，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。 常用的命令有：q（退出）、q!（强制退出）、w（保存）、wq（保存并退出）。 4. 可视模式 在正常模式中按下v, V, \u003cCtrl\u003e+v，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。  常用命令\n 1. 回到当前行的行首 0 2. 回到当前行的行尾 $ 3. 复制一行 yy 8yy //向下复制8行 4. 粘贴内容 p 5p //粘贴5次 5. 删除游标所在行，并进入插入模式 cc 6. 插入 i 插入到光标前面 I 插入到行的开始位置 a 插入到光标的后面 A 插入到行的最后位置 7.重复最后一个命令 . 8. 撤销上一步操作 u ","description":"","tags":["linux","vim"],"title":"Vim 一些好用的命令","uri":"/blog/linux/vim/"},{"categories":["git"],"content":"修改没有提交到暂存区,想要回滚怎么办 1  $ git checkout -- filename //回滚单个文件   1  $ git checkout . //回滚所有文件   代码写错了分支 git add . //把所有改动暂存 git stash //把暂存的文件提交到git的暂存栈 git checkout //迁出对应的分支 git stash pop //将暂存栈中的代码放出来 代码回滚 $ git reset --hard HEAD^ //回退到上个版本 $ git reset --hard HEAD~3 //回退到前3次提交之前，以此类推，回退到n次提交之前 $ git reset --hard commit_id //退到/进到 指定commit的sha码 ","description":"","tags":["git"],"title":"Git 一些好用的命令","uri":"/blog/git/usage/"},{"categories":["linux"],"content":"下载 ohmyzsh 1  $ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"   下载 zsh-autosuggestions  命令自动建议和补全\n 1  $ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions   下载 zsh-syntax-highlighting  使用 zsh 插件 zsh-syntax-highlighting 高亮你的可用命令\n 1  $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting   修改 ys THEMES 样式 $ vim ~/.oh-my-zsh/themes/ys.zsh-theme PROMPT=\" %{$terminfo[bold]$fg[yellow]%}%~%{$reset_color%}\\ ${hg_info}\\ \\ %{$fg[white]%}[%*] $exit_code %{$terminfo[bold]$fg[white]%}$ %{$reset_color%}\" 修改.zshrc # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"$HOME/.oh-my-zsh\" # Set name of the theme to load --- if set to \"random\", it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\"ys\" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\"true\" # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\"true\" # Uncomment the following line to disable bi-weekly auto-update checks. # DISABLE_AUTO_UPDATE=\"true\" # Uncomment the following line to automatically update without prompting. # DISABLE_UPDATE_PROMPT=\"true\" # Uncomment the following line to change how often to auto-update (in days). export UPDATE_ZSH_DAYS=13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\"true\" # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\"true\" # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\"true\" # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\"true\" # Uncomment the following line to display red dots whilst waiting for completion. # COMPLETION_WAITING_DOTS=\"true\" # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\"true\" # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\" # or set a custom format using the strftime function format specifications, # see 'man strftime' for details. HIST_STAMPS=\"mm/dd/yyyy\" # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=( git z zsh-autosuggestions extract web-search zsh-syntax-highlighting ) source $ZSH/oh-my-zsh.sh source $HOME/.alias_profile 在当前环境下读取并执行 FileName 中的命令 $ source ~/.zshrc ","description":"","tags":["linux","zsh"],"title":"快速搭建 Zsh环境及配置","uri":"/blog/linux/zsh/"},{"categories":["php"],"content":"有用的php命令行命令 1. 查看当前已安装的扩展 1  $ php -m   2. 查看当前php版本 1  $ php -v   3. 查看扩展版本 1  $ php --ri 扩展名   4. 快速查看扩展版本 1  $ php -i | less   5. 查看php配置文件路径 1  $ php -i | grep php.ini   6. 执行文件(检查代码语法是否正确) 1  $ php -f 文件名   7. 直接执行代码 1 2  $ php -r 'echo 1;' $ php -r \"echo ini_get('memory_limit');\"//查看内存限制   8. 检查代码语法 1  $ php -l 文件名   9. 查看帮助 1  $ php -h   10. 查看当前php可执行文件位置 1  $ which php   11. 开启服务 1  $ php -S 0.0.0.0:1234   12. 读取特定的ini文件 1  $ php -c /usr/local/etc/php/php.ini   13. 设置ini条目 1  $ php -d memory_limit=-1 `which composer` install   ","description":"","tags":["php"],"title":"Php Command Script","uri":"/blog/php/script/"}]
